{"version":3,"names":[],"mappings":"","sources":["packages/workbox-strategies/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.strategies = (function (logger_mjs,assert_mjs,cacheNames_mjs,cacheWrapper_mjs,fetchWrapper_mjs,getFriendlyURL_mjs,WorkboxError_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:strategies:4.0.0-beta.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  const getFriendlyURL = url => {\n    const urlObj = new URL(url, location);\n\n    if (urlObj.origin === location.origin) {\n      return urlObj.pathname;\n    }\n\n    return urlObj.href;\n  };\n\n  var messages = {\n    strategyStart: (strategyName, request) => `Using ${strategyName} to ` + `respond to '${getFriendlyURL(request.url)}'`,\n    printFinalResponse: response => {\n      if (response) {\n        logger_mjs.logger.groupCollapsed(`View the final response here.`);\n        logger_mjs.logger.unprefixed.log(response);\n        logger_mjs.logger.groupEnd();\n      }\n    }\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * An implementation of a [cache-first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-falling-back-to-network}\n   * request strategy.\n   *\n   * A cache first strategy is useful for assets that have been revisioned,\n   * such as URLs like `/styles/example.a8f5f1.css`, since they\n   * can be cached for long periods of time.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class CacheFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._fetchOptions = options.fetchOptions || null;\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n           be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'CacheFirst',\n          funcName: 'makeRequest',\n          paramName: 'request'\n        });\n      }\n\n      let response = await cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      let error;\n\n      if (!response) {\n        {\n          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will respond with a network request.`);\n        }\n\n        try {\n          response = await this._getFromNetwork(request, event);\n        } catch (err) {\n          error = err;\n        }\n\n        {\n          if (response) {\n            logs.push(`Got response from network.`);\n          } else {\n            logs.push(`Unable to get a response from the network.`);\n          }\n        }\n      } else {\n        {\n          logs.push(`Found a cached response in the '${this._cacheName}' cache.`);\n        }\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheFirst', request));\n\n        for (let log of logs) {\n          logger_mjs.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n    /**\n     * Handles the network and cache part of CacheFirst.\n     *\n     * @param {Request} request\n     * @param {FetchEvent} [event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getFromNetwork(request, event) {\n      const response = await fetchWrapper_mjs.fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins\n      }); // Keep the service worker while we put the request to the cache\n\n      const responseClone = response.clone();\n      const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: responseClone,\n        event,\n        plugins: this._plugins\n      });\n\n      if (event) {\n        try {\n          event.waitUntil(cachePutPromise);\n        } catch (error) {\n          {\n            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n\n      return response;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * An implementation of a\n   * [cache-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#cache-only}\n   * request strategy.\n   *\n   * This class is useful if you want to take advantage of any\n   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n   *\n   * If there is no cache match, this will throw a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class CacheOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'CacheOnly',\n          funcName: 'makeRequest',\n          paramName: 'request'\n        });\n      }\n\n      const response = await cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('CacheOnly', request));\n\n        if (response) {\n          logger_mjs.logger.log(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n          messages.printFinalResponse(response);\n        } else {\n          logger_mjs.logger.log(`No response found in the '${this._cacheName}' cache.`);\n        }\n\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n\n      return response;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  var cacheOkAndOpaquePlugin = {\n    /**\n     * Return return a response (i.e. allow caching) if the\n     * response is ok (i.e. 200) or is opaque.\n     *\n     * @param {Object} options\n     * @param {Response} options.response\n     * @return {Response|null}\n     *\n     * @private\n     */\n    cacheWillUpdate: ({\n      response\n    }) => {\n      if (response.ok || response.status === 0) {\n        return response;\n      }\n\n      return null;\n    }\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * An implementation of a\n   * [network first]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-falling-back-to-cache}\n   * request strategy.\n   *\n   * By default, this strategy will cache responses with a 200 status code as\n   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n   * Opaque responses are are cross-origin requests where the response doesn't\n   * support [CORS]{@link https://enable-cors.org/}.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class NetworkFirst {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     * @param {number} options.networkTimeoutSeconds If set, any network requests\n     * that fail to respond within the timeout will fallback to the cache.\n     *\n     * This option can be used to combat\n     * \"[lie-fi]{@link https://developers.google.com/web/fundamentals/performance/poor-connectivity/#lie-fi}\"\n     * scenarios.\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n\n      if (options.plugins) {\n        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n      } else {\n        // No plugins passed in, use the default plugin.\n        this._plugins = [cacheOkAndOpaquePlugin];\n      }\n\n      this._networkTimeoutSeconds = options.networkTimeoutSeconds;\n\n      {\n        if (this._networkTimeoutSeconds) {\n          assert_mjs.assert.isType(this._networkTimeoutSeconds, 'number', {\n            moduleName: 'workbox-strategies',\n            className: 'NetworkFirst',\n            funcName: 'constructor',\n            paramName: 'networkTimeoutSeconds'\n          });\n        }\n      }\n\n      this._fetchOptions = options.fetchOptions || null;\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkFirst',\n          funcName: 'handle',\n          paramName: 'makeRequest'\n        });\n      }\n\n      const promises = [];\n      let timeoutId;\n\n      if (this._networkTimeoutSeconds) {\n        const {\n          id,\n          promise\n        } = this._getTimeoutPromise({\n          request,\n          event,\n          logs\n        });\n\n        timeoutId = id;\n        promises.push(promise);\n      }\n\n      const networkPromise = this._getNetworkPromise({\n        timeoutId,\n        request,\n        event,\n        logs\n      });\n\n      promises.push(networkPromise); // Promise.race() will resolve as soon as the first promise resolves.\n\n      let response = await Promise.race(promises); // If Promise.race() resolved with null, it might be due to a network\n      // timeout + a cache miss. If that were to happen, we'd rather wait until\n      // the networkPromise resolves instead of returning null.\n      // Note that it's fine to await an already-resolved promise, so we don't\n      // have to check to see if it's still \"in flight\".\n\n      if (!response) {\n        response = await networkPromise;\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkFirst', request));\n\n        for (let log of logs) {\n          logger_mjs.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url\n        });\n      }\n\n      return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs array\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    _getTimeoutPromise({\n      request,\n      logs,\n      event\n    }) {\n      let timeoutId;\n      const timeoutPromise = new Promise(resolve => {\n        const onNetworkTimeout = async () => {\n          {\n            logs.push(`Timing out the network response at ` + `${this._networkTimeoutSeconds} seconds.`);\n          }\n\n          resolve((await this._respondFromCache({\n            request,\n            event\n          })));\n        };\n\n        timeoutId = setTimeout(onNetworkTimeout, this._networkTimeoutSeconds * 1000);\n      });\n      return {\n        promise: timeoutPromise,\n        id: timeoutId\n      };\n    }\n    /**\n     * @param {Object} options\n     * @param {number|undefined} options.timeoutId\n     * @param {Request} options.request\n     * @param {Array} options.logs A reference to the logs Array.\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getNetworkPromise({\n      timeoutId,\n      request,\n      logs,\n      event\n    }) {\n      let error;\n      let response;\n\n      try {\n        response = await fetchWrapper_mjs.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n      } catch (err) {\n        error = err;\n      }\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n\n      {\n        if (response) {\n          logs.push(`Got response from network.`);\n        } else {\n          logs.push(`Unable to get a response from the network. Will respond ` + `with a cached response.`);\n        }\n      }\n\n      if (error || !response) {\n        response = await this._respondFromCache({\n          request,\n          event\n        });\n\n        {\n          if (response) {\n            logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache.`);\n          } else {\n            logs.push(`No response found in the '${this._cacheName}' cache.`);\n          }\n        }\n      } else {\n        // Keep the service worker alive while we put the request in the cache\n        const responseClone = response.clone();\n        const cachePut = cacheWrapper_mjs.cacheWrapper.put({\n          cacheName: this._cacheName,\n          request,\n          response: responseClone,\n          event,\n          plugins: this._plugins\n        });\n\n        if (event) {\n          try {\n            // The event has been responded to so we can keep the SW alive to\n            // respond to the request\n            event.waitUntil(cachePut);\n          } catch (err) {\n            {\n              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n            }\n          }\n        }\n      }\n\n      return response;\n    }\n    /**\n     * Used if the network timeouts or fails to make the request.\n     *\n     * @param {Object} options\n     * @param {Request} request The request to match in the cache\n     * @param {Event} [options.event]\n     * @return {Promise<Object>}\n     *\n     * @private\n     */\n\n\n    _respondFromCache({\n      event,\n      request\n    }) {\n      return cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * An implementation of a\n   * [network-only]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#network-only}\n   * request strategy.\n   *\n   * This class is useful if you want to take advantage of any\n   * [Workbox plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}.\n   *\n   * If the network request fails, this will throw a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class NetworkOnly {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n      this._fetchOptions = options.fetchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'NetworkOnly',\n          funcName: 'handle',\n          paramName: 'request'\n        });\n      }\n\n      let error;\n      let response;\n\n      try {\n        response = await fetchWrapper_mjs.fetchWrapper.fetch({\n          request,\n          event,\n          fetchOptions: this._fetchOptions,\n          plugins: this._plugins\n        });\n      } catch (err) {\n        error = err;\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('NetworkOnly', request));\n\n        if (response) {\n          logger_mjs.logger.log(`Got response from network.`);\n        } else {\n          logger_mjs.logger.log(`Unable to get a response from the network.`);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * An implementation of a\n   * [stale-while-revalidate]{@link https://developers.google.com/web/fundamentals/instant-and-offline/offline-cookbook/#stale-while-revalidate}\n   * request strategy.\n   *\n   * Resources are requested from both the cache and the network in parallel.\n   * The strategy will respond with the cached version if available, otherwise\n   * wait for the network response. The cache is updated with the network response\n   * with each successful request.\n   *\n   * By default, this strategy will cache responses with a 200 status code as\n   * well as [opaque responses]{@link https://developers.google.com/web/tools/workbox/guides/handle-third-party-requests}.\n   * Opaque responses are are cross-origin requests where the response doesn't\n   * support [CORS]{@link https://enable-cors.org/}.\n   *\n   * If the network request fails, and there is no cache match, this will throw\n   * a `WorkboxError` exception.\n   *\n   * @memberof workbox.strategies\n   */\n\n  class StaleWhileRevalidate {\n    /**\n     * @param {Object} options\n     * @param {string} options.cacheName Cache name to store and retrieve\n     * requests. Defaults to cache names provided by\n     * [workbox-core]{@link workbox.core.cacheNames}.\n     * @param {Array<Object>} options.plugins [Plugins]{@link https://developers.google.com/web/tools/workbox/guides/using-plugins}\n     * to use in conjunction with this caching strategy.\n     * @param {Object} options.fetchOptions Values passed along to the\n     * [`init`](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n     * of all fetch() requests made by this strategy.\n     * @param {Object} options.matchOptions [`CacheQueryOptions`](https://w3c.github.io/ServiceWorker/#dictdef-cachequeryoptions)\n     */\n    constructor(options = {}) {\n      this._cacheName = cacheNames_mjs.cacheNames.getRuntimeName(options.cacheName);\n      this._plugins = options.plugins || [];\n\n      if (options.plugins) {\n        let isUsingCacheWillUpdate = options.plugins.some(plugin => !!plugin.cacheWillUpdate);\n        this._plugins = isUsingCacheWillUpdate ? options.plugins : [cacheOkAndOpaquePlugin, ...options.plugins];\n      } else {\n        // No plugins passed in, use the default plugin.\n        this._plugins = [cacheOkAndOpaquePlugin];\n      }\n\n      this._fetchOptions = options.fetchOptions || null;\n      this._matchOptions = options.matchOptions || null;\n    }\n    /**\n     * This method will perform a request strategy and follows an API that\n     * will work with the\n     * [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to run this strategy for.\n     * @param {Event} [options.event] The event that triggered the request.\n     * @return {Promise<Response>}\n     */\n\n\n    async handle({\n      event,\n      request\n    }) {\n      return this.makeRequest({\n        event,\n        request: request || event.request\n      });\n    }\n    /**\n     * This method can be used to perform a make a standalone request outside the\n     * context of the [Workbox Router]{@link workbox.routing.Router}.\n     *\n     * See \"[Advanced Recipes](https://developers.google.com/web/tools/workbox/guides/advanced-recipes#make-requests)\"\n     * for more usage information.\n     *\n     * @param {Object} options\n     * @param {Request|string} options.request Either a\n     *     [`Request`]{@link https://developer.mozilla.org/en-US/docs/Web/API/Request}\n     *     object, or a string URL, corresponding to the request to be made.\n     * @param {FetchEvent} [options.event] If provided, `event.waitUntil()` will\n     *     be called automatically to extend the service worker's lifetime.\n     * @return {Promise<Response>}\n     */\n\n\n    async makeRequest({\n      event,\n      request\n    }) {\n      const logs = [];\n\n      if (typeof request === 'string') {\n        request = new Request(request);\n      }\n\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-strategies',\n          className: 'StaleWhileRevalidate',\n          funcName: 'handle',\n          paramName: 'request'\n        });\n      }\n\n      const fetchAndCachePromise = this._getFromNetwork({\n        request,\n        event\n      });\n\n      let response = await cacheWrapper_mjs.cacheWrapper.match({\n        cacheName: this._cacheName,\n        request,\n        event,\n        matchOptions: this._matchOptions,\n        plugins: this._plugins\n      });\n      let error;\n\n      if (response) {\n        {\n          logs.push(`Found a cached response in the '${this._cacheName}'` + ` cache. Will update with the network response in the background.`);\n        }\n\n        if (event) {\n          try {\n            event.waitUntil(fetchAndCachePromise);\n          } catch (error) {\n            {\n              logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n            }\n          }\n        }\n      } else {\n        {\n          logs.push(`No response found in the '${this._cacheName}' cache. ` + `Will wait for the network response.`);\n        }\n\n        try {\n          response = await fetchAndCachePromise;\n        } catch (err) {\n          error = err;\n        }\n      }\n\n      {\n        logger_mjs.logger.groupCollapsed(messages.strategyStart('StaleWhileRevalidate', request));\n\n        for (let log of logs) {\n          logger_mjs.logger.log(log);\n        }\n\n        messages.printFinalResponse(response);\n        logger_mjs.logger.groupEnd();\n      }\n\n      if (!response) {\n        throw new WorkboxError_mjs.WorkboxError('no-response', {\n          url: request.url,\n          error\n        });\n      }\n\n      return response;\n    }\n    /**\n     * @param {Object} options\n     * @param {Request} options.request\n     * @param {Event} [options.event]\n     * @return {Promise<Response>}\n     *\n     * @private\n     */\n\n\n    async _getFromNetwork({\n      request,\n      event\n    }) {\n      const response = await fetchWrapper_mjs.fetchWrapper.fetch({\n        request,\n        event,\n        fetchOptions: this._fetchOptions,\n        plugins: this._plugins\n      });\n      const cachePutPromise = cacheWrapper_mjs.cacheWrapper.put({\n        cacheName: this._cacheName,\n        request,\n        response: response.clone(),\n        event,\n        plugins: this._plugins\n      });\n\n      if (event) {\n        try {\n          event.waitUntil(cachePutPromise);\n        } catch (error) {\n          {\n            logger_mjs.logger.warn(`Unable to ensure service worker stays alive when ` + `updating cache for '${getFriendlyURL_mjs.getFriendlyURL(event.request.url)}'.`);\n          }\n        }\n      }\n\n      return response;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  var publicAPI = /*#__PURE__*/Object.freeze({\n    CacheFirst: CacheFirst,\n    CacheOnly: CacheOnly,\n    NetworkFirst: NetworkFirst,\n    NetworkOnly: NetworkOnly,\n    StaleWhileRevalidate: StaleWhileRevalidate\n  });\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * @function workbox.strategies.cacheFirst\n   * @param {Object} options See the {@link workbox.strategies.CacheFirst}\n   * constructor for more info.\n   */\n\n  /**\n   * @function workbox.strategies.cacheOnly\n   * @param {Object} options See the {@link workbox.strategies.CacheOnly}\n   * constructor for more info.\n   */\n\n  /**\n   * @function workbox.strategies.networkFirst\n   * @param {Object} options See the {@link workbox.strategies.NetworkFirst}\n   * constructor for more info.\n   */\n\n  /**\n   * @function workbox.strategies.networkOnly\n   * @param {Object} options See the {@link workbox.strategies.NetworkOnly}\n   * constructor for more info.\n   */\n\n  /**\n   * @function workbox.strategies.staleWhileRevalidate\n   * @param {Object} options See the\n   * {@link workbox.strategies.StaleWhileRevalidate} constructor for more info.\n   */\n\n  const mapping = {\n    cacheFirst: CacheFirst,\n    cacheOnly: CacheOnly,\n    networkFirst: NetworkFirst,\n    networkOnly: NetworkOnly,\n    staleWhileRevalidate: StaleWhileRevalidate\n  };\n  const defaultExport = {};\n  Object.keys(mapping).forEach(keyName => {\n    defaultExport[keyName] = (options = {}) => {\n      const StrategyClass = mapping[keyName];\n      return new StrategyClass(Object.assign(options));\n    };\n  });\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const finalExport = Object.assign(defaultExport, publicAPI);\n\n  return finalExport;\n\n}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private));\n"],"file":"workbox-strategies.dev.js"}