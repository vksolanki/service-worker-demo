{"version":3,"names":[],"mappings":"","sources":["packages/workbox-streams/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.streams = (function (exports,logger_mjs,assert_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:streams:4.0.0-beta.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Takes either a Response, a ReadableStream, or a\n   * [BodyInit](https://fetch.spec.whatwg.org/#bodyinit) and returns the\n   * ReadableStreamReader object associated with it.\n   *\n   * @param {workbox.streams.StreamSource} source\n   * @return {ReadableStreamReader}\n   * @private\n   */\n\n  function _getReaderFromSource(source) {\n    if (source.body && source.body.getReader) {\n      return source.body.getReader();\n    }\n\n    if (source.getReader) {\n      return source.getReader();\n    } // TODO: This should be possible to do by constructing a ReadableStream, but\n    // I can't get it to work. As a hack, construct a new Response, and use the\n    // reader associated with its body.\n\n\n    return new Response(source).body.getReader();\n  }\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit).\n   *\n   * Returns an object exposing a ReadableStream with each individual stream's\n   * data returned in sequence, along with a Promise which signals when the\n   * stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n   * @return {Object<{done: Promise, stream: ReadableStream}>}\n   *\n   * @memberof workbox.streams\n   */\n\n\n  function concatenate(sourcePromises) {\n    {\n      assert_mjs.assert.isArray(sourcePromises, {\n        moduleName: 'workbox-streams',\n        funcName: 'concatenate',\n        paramName: 'sourcePromises'\n      });\n    }\n\n    const readerPromises = sourcePromises.map(sourcePromise => {\n      return Promise.resolve(sourcePromise).then(source => {\n        return _getReaderFromSource(source);\n      });\n    });\n    let fullyStreamedResolve;\n    let fullyStreamedReject;\n    const done = new Promise((resolve, reject) => {\n      fullyStreamedResolve = resolve;\n      fullyStreamedReject = reject;\n    });\n    let i = 0;\n    const logMessages = [];\n    const stream = new ReadableStream({\n      pull(controller) {\n        return readerPromises[i].then(reader => reader.read()).then(result => {\n          if (result.done) {\n            {\n              logMessages.push(['Reached the end of source:', sourcePromises[i]]);\n            }\n\n            i++;\n\n            if (i >= readerPromises.length) {\n              // Log all the messages in the group at once in a single group.\n              {\n                logger_mjs.logger.groupCollapsed(`Concatenating ${readerPromises.length} sources.`);\n\n                for (const message of logMessages) {\n                  if (Array.isArray(message)) {\n                    logger_mjs.logger.log(...message);\n                  } else {\n                    logger_mjs.logger.log(message);\n                  }\n                }\n\n                logger_mjs.logger.log('Finished reading all sources.');\n                logger_mjs.logger.groupEnd();\n              }\n\n              controller.close();\n              fullyStreamedResolve();\n              return;\n            }\n\n            return this.pull(controller);\n          } else {\n            controller.enqueue(result.value);\n          }\n        }).catch(error => {\n          {\n            logger_mjs.logger.error('An error occurred:', error);\n          }\n\n          fullyStreamedReject(error);\n          throw error;\n        });\n      },\n\n      cancel() {\n        {\n          logger_mjs.logger.warn('The ReadableStream was cancelled.');\n        }\n\n        fullyStreamedResolve();\n      }\n\n    });\n    return {\n      done,\n      stream\n    };\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * is available.\n   *\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof workbox.streams\n   */\n\n  function createHeaders(headersInit = {}) {\n    // See https://github.com/GoogleChrome/workbox/issues/1461\n    const headers = new Headers(headersInit);\n\n    if (!headers.has('content-type')) {\n      headers.set('content-type', 'text/html');\n    }\n\n    return headers;\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Takes multiple source Promises, each of which could resolve to a Response, a\n   * ReadableStream, or a [BodyInit](https://fetch.spec.whatwg.org/#bodyinit),\n   * along with a\n   * [HeadersInit](https://fetch.spec.whatwg.org/#typedefdef-headersinit).\n   *\n   * Returns an object exposing a Response whose body consists of each individual\n   * stream's data returned in sequence, along with a Promise which signals when\n   * the stream is finished (useful for passing to a FetchEvent's waitUntil()).\n   *\n   * @param {Array<Promise<workbox.streams.StreamSource>>} sourcePromises\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {Object<{done: Promise, response: Response}>}\n   *\n   * @memberof workbox.streams\n   */\n\n  function concatenateToResponse(sourcePromises, headersInit) {\n    const {\n      done,\n      stream\n    } = concatenate(sourcePromises);\n    const headers = createHeaders(headersInit);\n    const response = new Response(stream, {\n      headers\n    });\n    return {\n      done,\n      response\n    };\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  let cachedIsSupported = undefined;\n  /**\n   * This is a utility method that determines whether the current browser supports\n   * the features required to create streamed responses. Currently, it checks if\n   * [`ReadableStream`](https://developer.mozilla.org/en-US/docs/Web/API/ReadableStream/ReadableStream)\n   * can be created.\n   *\n   * @return {boolean} `true`, if the current browser meets the requirements for\n   * streaming responses, and `false` otherwise.\n   *\n   * @memberof workbox.streams\n   */\n\n  function isSupported() {\n    if (cachedIsSupported === undefined) {\n      // See https://github.com/GoogleChrome/workbox/issues/1473\n      try {\n        new ReadableStream({\n          start() {}\n\n        });\n        cachedIsSupported = true;\n      } catch (error) {\n        cachedIsSupported = false;\n      }\n    }\n\n    return cachedIsSupported;\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * A shortcut to create a strategy that could be dropped-in to Workbox's router.\n   *\n   * On browsers that do not support constructing new `ReadableStream`s, this\n   * strategy will automatically wait for all the `sourceFunctions` to complete,\n   * and create a final response that concatenates their values together.\n   *\n   * @param {\n   *   Array<function(workbox.routing.Route~handlerCallback)>} sourceFunctions\n   * Each function should return a {@link workbox.streams.StreamSource} (or a\n   * Promise which resolves to one).\n   * @param {HeadersInit} [headersInit] If there's no `Content-Type` specified,\n   * `'text/html'` will be used by default.\n   * @return {workbox.routing.Route~handlerCallback}\n   *\n   * @memberof workbox.streams\n   */\n\n  function strategy(sourceFunctions, headersInit) {\n    return async ({\n      event,\n      url,\n      params\n    }) => {\n      if (isSupported()) {\n        const {\n          done,\n          response\n        } = concatenateToResponse(sourceFunctions.map(fn => fn({\n          event,\n          url,\n          params\n        })), headersInit);\n        event.waitUntil(done);\n        return response;\n      }\n\n      {\n        logger_mjs.logger.log(`The current browser doesn't support creating response ` + `streams. Falling back to non-streaming response instead.`);\n      } // Fallback to waiting for everything to finish, and concatenating the\n      // responses.\n\n\n      const parts = await Promise.all(sourceFunctions.map(sourceFunction => sourceFunction({\n        event,\n        url,\n        params\n      })).map(async responsePromise => {\n        const response = await responsePromise;\n\n        if (response instanceof Response) {\n          return response.blob();\n        } // Otherwise, assume it's something like a string which can be used\n        // as-is when constructing the final composite blob.\n\n\n        return response;\n      }));\n      const headers = createHeaders(headersInit); // Constructing a new Response from a Blob source is well-supported.\n      // So is constructing a new Blob from multiple source Blobs or strings.\n\n      return new Response(new Blob(parts), {\n        headers\n      });\n    };\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  exports.concatenate = concatenate;\n  exports.concatenateToResponse = concatenateToResponse;\n  exports.isSupported = isSupported;\n  exports.strategy = strategy;\n\n  return exports;\n\n}({},workbox.core._private,workbox.core._private));\n"],"file":"workbox-streams.dev.js"}