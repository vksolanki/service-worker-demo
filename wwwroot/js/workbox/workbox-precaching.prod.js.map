{"version":3,"names":[],"mappings":"","sources":["packages/workbox-precaching/browser.mjs"],"sourcesContent":["this.workbox=this.workbox||{},this.workbox.precaching=function(t,e,s,n,a){\"use strict\";try{self.workbox.v[\"workbox:precaching:4.0.0-beta.0\"]=1}catch(t){}class i{constructor(t,e,s,n){this.t=t,this.e=e,this.s=s;const a=new Request(e,{credentials:\"same-origin\"});this.n=a,this.a=n?this.i(a):a}i(t){let e=t.url;const s={credentials:\"same-origin\"};if(\"cache\"in Request.prototype)s.cache=\"reload\";else{const t=new URL(e,location),s=encodeURIComponent;t.search+=(t.search?\"&\":\"\")+s(\"_workbox-cache-bust\")+\"=\"+s(this.s),e=t.toString()}return new Request(e,s)}}const c=\"revision\",r=\"url\",o=\"precached-details-models\";class h{constructor(e){const s=e.replace(/[^\\w-]/g,\"_\");this.c=new t.DBWrapper(s,2,{onupgradeneeded:this.r})}r(t){const e=t.target.result;t.oldVersion<2&&(e.objectStoreNames.contains(\"workbox-precaching\")&&e.deleteObjectStore(\"workbox-precaching\"),e.objectStoreNames.contains(o)&&e.deleteObjectStore(o)),e.createObjectStore(o)}async o(t,e){if(await this.h(e.e)!==e.s)return!1;const s=await caches.open(t);return!!await s.match(e.n)}async l(){return await this.c.getAllMatching(o,{includeKeys:!0})}async h(t){const e=await this.c.get(o,t);return e?e[c]:null}async u(t){await this.c.put(o,{[c]:t.s,[r]:t.n.url},t.e)}async w(t){await this.c.delete(o,t)}}const l=async t=>{const e=t.clone(),s=\"body\"in e?Promise.resolve(e.body):e.blob(),n=await s;return new Response(n,{headers:e.headers,status:e.status,statusText:e.statusText})};class u{constructor(t){this.d=e.cacheNames.getPrecacheName(t),this.p=new Map,this.f=new h(this.d)}addToCacheList(t){t.map(t=>{this.y(this.g(t))})}g(t){switch(typeof t){case\"string\":return new i(t,t,t);case\"object\":return new i(t,t.url,t.revision||t.url,!!t.revision);default:throw new s.WorkboxError(\"add-to-cache-list-unexpected-type\",{entry:t})}}y(t){const e=this.p.get(t.e);if(e){if(e.s!==t.s)throw new s.WorkboxError(\"add-to-cache-list-conflicting-entries\",{firstEntry:e.t,secondEntry:t.t})}else this.p.set(t.e,t)}async install({suppressWarnings:t=!1,event:e,plugins:s}={}){const n=await caches.open(this.m()),a=await n.keys();await Promise.all(a.map(t=>n.delete(t)));const i=[],c=[];for(const t of this.p.values())await this.f.o(this.d,t)?c.push(t):i.push(t);return await Promise.all(i.map(t=>this.R({event:e,plugins:s,precacheEntry:t}))),{updatedEntries:i,notUpdatedEntries:c}}async activate(t={}){const e=await caches.open(this.m()),s=await e.keys();for(const n of s){const s=await e.match(n);await a.cacheWrapper.put({cacheName:this.d,request:n,response:s,plugins:t.plugins}),await e.delete(n)}return await caches.delete(this.m()),this._()}m(){return`${this.d}-temp`}async R({precacheEntry:t,event:e,plugins:i}){let c,r=await n.fetchWrapper.fetch({request:t.a,event:e,fetchOptions:null,plugins:i});for(const t of i||[])\"cacheWillUpdate\"in t&&(c=t.cacheWillUpdate);if(!(c?c({response:r}):r.status<400))throw new s.WorkboxError(\"bad-precaching-response\",{url:t.a.url,status:r.status});return r.redirected&&(r=await l(r)),await a.cacheWrapper.put({cacheName:this.m(),request:t.n,response:r,event:e,plugins:i}),await this.f.u(t),!0}async _(){const t=[];this.p.forEach(e=>{const s=new URL(e.n.url,location).toString();t.push(s)});const[e,s]=await Promise.all([this.U(t),this.b(t)]);return{deletedCacheRequests:e,deletedRevisionDetails:s}}async U(t){if(!await caches.has(this.d))return[];const e=await caches.open(this.d),s=(await e.keys()).filter(e=>!t.includes(new URL(e.url,location).toString()));return await Promise.all(s.map(t=>e.delete(t))),s.map(t=>t.url)}async b(t){const e=(await this.f.l()).filter(e=>{const s=new URL(e.value.url,location).toString();return!t.includes(s)});return await Promise.all(e.map(t=>this.f.w(t.primaryKey))),e.map(t=>t.value.url)}getCachedUrls(){return Array.from(this.p.keys()).map(t=>new URL(t,location).href)}}var w=Object.freeze({PrecacheController:u});let d=!1,p=!1,f=!1,y=[];const g=e.cacheNames.getPrecacheName(),m=new u(g),R=(t,{ignoreUrlParametersMatching:e=[/^utm_/],directoryIndex:s=\"index.html\",cleanUrls:n=!0,urlManipulation:a=null}={})=>{const i=new URL(t,location);i.hash=\"\";const c=((t,e)=>{const s=t.search.slice(1).split(\"&\").map(t=>t.split(\"=\")).filter(t=>e.every(e=>!e.test(t[0]))).map(t=>t.join(\"=\")),n=new URL(t);return n.search=s.join(\"&\"),n})(i,e);let r=[i,c];if(s&&c.pathname.endsWith(\"/\")){const t=new URL(c);t.pathname+=s,r.push(t)}if(n){const t=new URL(c);t.pathname+=\".html\",r.push(t)}if(a){const t=a({url:i});r=r.concat(t)}const o=m.getCachedUrls();for(const t of r)if(-1!==o.indexOf(t.href))return t.href;return null},_={precache:t=>{m.addToCacheList(t),d||t.length<=0||(d=!0,self.addEventListener(\"install\",t=>{t.waitUntil(m.install({event:t,plugins:y,suppressWarnings:f}).catch(t=>{throw t}))}),self.addEventListener(\"activate\",t=>{t.waitUntil(m.activate({event:t,plugins:y}))}))},addRoute:t=>{p||(p=!0,self.addEventListener(\"fetch\",e=>{const s=R(e.request.url,t);if(!s)return;let n=caches.open(g).then(t=>t.match(s)).then(t=>t||fetch(s));e.respondWith(n)}))},precacheAndRoute:(t,e)=>{_.precache(t),_.addRoute(e)},suppressWarnings:t=>{f=t},addPlugins:t=>{y=y.concat(t)}};return Object.assign(_,w)}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);\n"],"file":"workbox-precaching.prod.js"}