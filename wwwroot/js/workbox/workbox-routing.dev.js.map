{"version":3,"names":[],"mappings":"","sources":["packages/workbox-routing/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.routing = (function (assert_mjs,logger_mjs,WorkboxError_mjs,getFriendlyURL_mjs,cacheNames_mjs) {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:routing:4.0.0-beta.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * The default HTTP method, 'GET', used when there's no specific method\n   * configured for a route.\n   *\n   * @type {string}\n   *\n   * @private\n   */\n\n  const defaultMethod = 'GET';\n  /**\n   * The list of valid HTTP methods associated with requests that could be routed.\n   *\n   * @type {Array<string>}\n   *\n   * @private\n   */\n\n  const validMethods = ['DELETE', 'GET', 'HEAD', 'PATCH', 'POST', 'PUT'];\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * @param {function()|Object} handler Either a function, or an object with a\n   * 'handle' method.\n   * @return {Object} An object with a handle method.\n   *\n   * @private\n   */\n\n  var normalizeHandler = (handler => {\n    if (handler && typeof handler === 'object') {\n      {\n        assert_mjs.assert.hasMethod(handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Route',\n          funcName: 'constructor',\n          paramName: 'handler'\n        });\n      }\n\n      return handler;\n    } else {\n      {\n        assert_mjs.assert.isType(handler, 'function', {\n          moduleName: 'workbox-routing',\n          className: 'Route',\n          funcName: 'constructor',\n          paramName: 'handler'\n        });\n      }\n\n      return {\n        handle: handler\n      };\n    }\n  });\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n   * The \"match\" callback determine if a route should be used to \"handle\" a\n   * request by returning a non-falsy value if it can. The \"handler\" callback\n   * is called when there is a match and should return a Promise that resolves\n   * to a `Response`.\n   *\n   * @memberof workbox.routing\n   */\n\n  class Route {\n    /**\n     * Constructor for Route class.\n     *\n     * @param {workbox.routing.Route~matchCallback} match\n     * A callback function that determines whether the route matches a given\n     * `fetch` event by returning a non-falsy value.\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resolving to a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(match, handler, method) {\n      {\n        assert_mjs.assert.isType(match, 'function', {\n          moduleName: 'workbox-routing',\n          className: 'Route',\n          funcName: 'constructor',\n          paramName: 'match'\n        });\n\n        if (method) {\n          assert_mjs.assert.isOneOf(method, validMethods, {\n            paramName: 'method'\n          });\n        }\n      } // These values are referenced directly by Router so cannot be\n      // altered by minifification.\n\n\n      this.handler = normalizeHandler(handler);\n      this.match = match;\n      this.method = method || defaultMethod;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * NavigationRoute makes it easy to create a [Route]{@link\n   * workbox.routing.Route} that matches for browser\n   * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n   *\n   * It will only match incoming Requests whose\n   * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\n   * is set to `navigate`.\n   *\n   * You can optionally only apply this route to a subset of navigation requests\n   * by using one or both of the `blacklist` and `whitelist` parameters.\n   *\n   * @memberof workbox.routing\n   * @extends workbox.routing.Route\n   */\n\n  class NavigationRoute extends Route {\n    /**\n     * If both `blacklist` and `whiltelist` are provided, the `blacklist` will\n     * take precedence and the request will not match this route.\n     *\n     * The regular expressions in `whitelist` and `blacklist`\n     * are matched against the concatenated\n     * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n     * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n     * portions of the requested URL.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {Object} options\n     * @param {Array<RegExp>} [options.blacklist] If any of these patterns match,\n     * the route will not handle the request (even if a whitelist RegExp matches).\n     * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n     * match the URL's pathname and search parameter, the route will handle the\n     * request (assuming the blacklist doesn't match).\n     */\n    constructor(handler, {\n      whitelist = [/./],\n      blacklist = []\n    } = {}) {\n      {\n        assert_mjs.assert.isArrayOfClass(whitelist, RegExp, {\n          moduleName: 'workbox-routing',\n          className: 'NavigationRoute',\n          funcName: 'constructor',\n          paramName: 'options.whitelist'\n        });\n        assert_mjs.assert.isArrayOfClass(blacklist, RegExp, {\n          moduleName: 'workbox-routing',\n          className: 'NavigationRoute',\n          funcName: 'constructor',\n          paramName: 'options.blacklist'\n        });\n      }\n\n      super(options => this._match(options), handler);\n      this._whitelist = whitelist;\n      this._blacklist = blacklist;\n    }\n    /**\n     * Routes match handler.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request\n     * @return {boolean}\n     *\n     * @private\n     */\n\n\n    _match({\n      url,\n      request\n    }) {\n      if (request.mode !== 'navigate') {\n        return false;\n      }\n\n      const pathnameAndSearch = url.pathname + url.search;\n\n      for (const regExp of this._blacklist) {\n        if (regExp.test(pathnameAndSearch)) {\n          {\n            logger_mjs.logger.log(`The navigation route is not being used, since the ` + `URL matches this blacklist pattern: ${regExp}`);\n          }\n\n          return false;\n        }\n      }\n\n      if (this._whitelist.some(regExp => regExp.test(pathnameAndSearch))) {\n        {\n          logger_mjs.logger.debug(`The navigation route is being used.`);\n        }\n\n        return true;\n      }\n\n      {\n        logger_mjs.logger.log(`The navigation route is not being used, since the URL ` + `being navigated to doesn't match the whitelist.`);\n      }\n\n      return false;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * RegExpRoute makes it easy to create a regular expression based\n   * [Route]{@link workbox.routing.Route}.\n   *\n   * For same-origin requests the RegExp only needs to match part of the URL. For\n   * requests against third-party servers, you must define a RegExp that matches\n   * the start of the URL.\n   *\n   * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/modules/workbox-routing}\n   *\n   * @memberof workbox.routing\n   * @extends workbox.routing.Route\n   */\n\n  class RegExpRoute extends Route {\n    /**\n     * If the regulard expression contains\n     * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n     * th ecaptured values will be passed to the\n     * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n     * argument.\n     *\n     * @param {RegExp} regExp The regular expression to match against URLs.\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     */\n    constructor(regExp, handler, method) {\n      {\n        assert_mjs.assert.isInstance(regExp, RegExp, {\n          moduleName: 'workbox-routing',\n          className: 'RegExpRoute',\n          funcName: 'constructor',\n          paramName: 'pattern'\n        });\n      }\n\n      const match = ({\n        url\n      }) => {\n        const result = regExp.exec(url.href); // Return null immediately if there's no match.\n\n        if (!result) {\n          return null;\n        } // Require that the match start at the first character in the URL string\n        // if it's a cross-origin request.\n        // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n        // behind this behavior.\n\n\n        if (url.origin !== location.origin && result.index !== 0) {\n          {\n            logger_mjs.logger.debug(`The regular expression '${regExp}' only partially matched ` + `against the cross-origin URL '${url}'. RegExpRoute's will only ` + `handle cross-origin requests if they match the entire URL.`);\n          }\n\n          return null;\n        } // If the route matches, but there aren't any capture groups defined, then\n        // this will return [], which is truthy and therefore sufficient to\n        // indicate a match.\n        // If there are capture groups, then it will return their values.\n\n\n        return result.slice(1);\n      };\n\n      super(match, handler, method);\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * The Router can be used to process a FetchEvent through one or more\n   * [Routes]{@link workbox.routing.Route} responding  with a Request if\n   * a matching route exists.\n   *\n   * If no route matches a given a request, the Router will use a \"default\"\n   * handler if one is defined.\n   *\n   * Should the matching Route throw an error, the Router will use a \"catch\"\n   * handler if one is defined to gracefully deal with issues and respond with a\n   * Request.\n   *\n   * If a request matches multiple routes, the **earliest** registered route will\n   * be used to respond to the request.\n   *\n   * @memberof workbox.routing\n   */\n\n  class Router {\n    /**\n     * Initializes a new Router.\n     */\n    constructor() {\n      this._routes = new Map();\n    }\n    /**\n     * @return {Map<string, Array<workbox.routing.Route>>} routes A `Map` of HTTP\n     * method name ('GET', etc.) to an array of all the corresponding `Route`\n     * instances that are registered.\n     */\n\n\n    get routes() {\n      return this._routes;\n    }\n    /**\n     * Adds a fetch event listener to respond to events when a route matches\n     * the event's request.\n     */\n\n\n    addFetchListener() {\n      self.addEventListener('fetch', event => {\n        const {\n          request\n        } = event;\n        const responsePromise = this.handleRequest({\n          request,\n          event\n        });\n\n        if (responsePromise) {\n          event.respondWith(responsePromise);\n        }\n      });\n    }\n    /**\n     * Adds a message event listener for URLs to cache from the window.\n     * This is useful to cache resources loaded prior to when the service worker\n     * started controlling the page.\n     */\n\n\n    addCacheListener() {\n      self.addEventListener('message', event => {\n        if (event.data.type === 'CACHE_URLS' && event.data.meta === 'workbox-window') {\n          const {\n            urlsToCache\n          } = event.data.payload;\n\n          {\n            logger_mjs.logger.debug(`Caching URLs from the window`, urlsToCache);\n          }\n\n          for (const url of urlsToCache) {\n            const request = new Request(url);\n            this.handleRequest({\n              request,\n              event\n            });\n          }\n        }\n      });\n    }\n    /**\n     * Apply the routing rules to a FetchEvent object to get a Response from an\n     * appropriate Route's handler.\n     *\n     * @param {Object} options\n     * @param {Request} options.request The request to handle (this is usually\n     *     from a fetch event, but it does not have to be).\n     * @param {FetchEvent} [options.event] The event that triggered the request,\n     *     if applicable.\n     * @return {Promise<Response>|undefined} A promise is returned if a\n     *     registered route can handle the request. If there is no matching\n     *     route and there's no `defaultHandler`, `undefined` is returned.\n     */\n\n\n    handleRequest({\n      request,\n      event\n    }) {\n      {\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'handleRequest',\n          paramName: 'options.request'\n        });\n      }\n\n      const url = new URL(request.url, location);\n\n      if (!url.protocol.startsWith('http')) {\n        {\n          logger_mjs.logger.debug(`Workbox Router only supports URLs that start with 'http'.`);\n        }\n\n        return;\n      }\n\n      let {\n        params,\n        route\n      } = this.findMatchingRoute({\n        url,\n        request,\n        event\n      });\n      let handler = route && route.handler;\n      let debugMessages = [];\n\n      {\n        if (handler) {\n          debugMessages.push([`Found a route to handle this request:`, route]);\n\n          if (params) {\n            debugMessages.push([`Passing the following params to the route's handler:`, params]);\n          }\n        }\n      } // If we don't have a handler because there was no matching route, then\n      // fall back to defaultHandler if that's defined.\n\n\n      if (!handler && this._defaultHandler) {\n        {\n          debugMessages.push(`Failed to find a matching route. Falling ` + `back to the default handler.`); // This is used for debugging in logs in the case of an error.\n\n          route = '[Default Handler]';\n        }\n\n        handler = this._defaultHandler;\n      }\n\n      if (!handler) {\n        {\n          // No handler so Workbox will do nothing. If logs is set of debug\n          // i.e. verbose, we should print out this information.\n          logger_mjs.logger.debug(`No route found for: ${getFriendlyURL_mjs.getFriendlyURL(url)}`);\n        }\n\n        return;\n      }\n\n      {\n        // We have a handler, meaning Workbox is going to handle the route.\n        // print the routing details to the console.\n        logger_mjs.logger.groupCollapsed(`Router is responding to: ${getFriendlyURL_mjs.getFriendlyURL(url)}`);\n        debugMessages.forEach(msg => {\n          if (Array.isArray(msg)) {\n            logger_mjs.logger.log(...msg);\n          } else {\n            logger_mjs.logger.log(msg);\n          }\n        }); // The Request and Response objects contains a great deal of information,\n        // hide it under a group in case developers want to see it.\n\n        logger_mjs.logger.groupCollapsed(`View request details here.`);\n        logger_mjs.logger.unprefixed.log(request);\n        logger_mjs.logger.groupEnd();\n        logger_mjs.logger.groupEnd();\n      } // Wrap in try and catch in case the handle method throws a synchronous\n      // error. It should still callback to the catch handler.\n\n\n      let responsePromise;\n\n      try {\n        responsePromise = handler.handle({\n          url,\n          request,\n          event,\n          params\n        });\n      } catch (err) {\n        responsePromise = Promise.reject(err);\n      }\n\n      if (responsePromise && this._catchHandler) {\n        responsePromise = responsePromise.catch(err => {\n          {\n            // Still include URL here as it will be async from the console group\n            // and may not make sense without the URL\n            logger_mjs.logger.groupCollapsed(`Error thrown when responding to: ` + ` ${getFriendlyURL_mjs.getFriendlyURL(url)}. Falling back to Catch Handler.`);\n            logger_mjs.logger.unprefixed.error(`Error thrown by:`, route);\n            logger_mjs.logger.unprefixed.error(err);\n            logger_mjs.logger.groupEnd();\n          }\n\n          return this._catchHandler.handle({\n            url,\n            event,\n            err\n          });\n        });\n      }\n\n      return responsePromise;\n    }\n    /**\n     * Checks a request and URL (and optionally an event) against the list of\n     * registered routes, and if there's a match, returns the corresponding\n     * route along with any params generated by the match.\n     *\n     * @param {Object} options\n     * @param {URL} options.url\n     * @param {Request} options.request The request to match.\n     * @param {FetchEvent} [options.event] The corresponding event (unless N/A).\n     * @return {Object} An object with `route` and `params` properties.\n     *     They are populated if a matching route was found or `undefined`\n     *     otherwise.\n     */\n\n\n    findMatchingRoute({\n      url,\n      request,\n      event\n    }) {\n      {\n        assert_mjs.assert.isInstance(url, URL, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'findMatchingRoute',\n          paramName: 'options.url'\n        });\n        assert_mjs.assert.isInstance(request, Request, {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'findMatchingRoute',\n          paramName: 'options.request'\n        });\n      }\n\n      const routes = this._routes.get(request.method) || [];\n\n      for (const route of routes) {\n        let params;\n        let matchResult = route.match({\n          url,\n          request,\n          event\n        });\n\n        if (matchResult) {\n          if (Array.isArray(matchResult) && matchResult.length > 0) {\n            // Instead of passing an empty array in as params, use undefined.\n            params = matchResult;\n          } else if (matchResult.constructor === Object && Object.keys(matchResult).length > 0) {\n            // Instead of passing an empty object in as params, use undefined.\n            params = matchResult;\n          } // Return early if have a match.\n\n\n          return {\n            route,\n            params\n          };\n        }\n      } // If no match was found above, return and empty object.\n\n\n      return {};\n    }\n    /**\n     * Define a default `handler` that's called when no routes explicitly\n     * match the incoming request.\n     *\n     * Without a default handler, unmatched requests will go against the\n     * network as if there were no service worker present.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n\n\n    setDefaultHandler(handler) {\n      this._defaultHandler = normalizeHandler(handler);\n    }\n    /**\n     * If a Route throws an error while handling a request, this `handler`\n     * will be called and given a chance to provide a response.\n     *\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     */\n\n\n    setCatchHandler(handler) {\n      this._catchHandler = normalizeHandler(handler);\n    }\n    /**\n     * Registers a route with the router.\n     *\n     * @param {workbox.routing.Route} route The route to register.\n     */\n\n\n    registerRoute(route) {\n      {\n        assert_mjs.assert.isType(route, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert_mjs.assert.hasMethod(route, 'match', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert_mjs.assert.isType(route.handler, 'object', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route'\n        });\n        assert_mjs.assert.hasMethod(route.handler, 'handle', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.handler'\n        });\n        assert_mjs.assert.isType(route.method, 'string', {\n          moduleName: 'workbox-routing',\n          className: 'Router',\n          funcName: 'registerRoute',\n          paramName: 'route.method'\n        });\n      }\n\n      if (!this._routes.has(route.method)) {\n        this._routes.set(route.method, []);\n      } // Give precedence to all of the earlier routes by adding this additional\n      // route to the end of the array.\n\n\n      this._routes.get(route.method).push(route);\n    }\n    /**\n     * Unregisters a route with the router.\n     *\n     * @param {workbox.routing.Route} route The route to unregister.\n     */\n\n\n    unregisterRoute(route) {\n      if (!this._routes.has(route.method)) {\n        throw new WorkboxError_mjs.WorkboxError('unregister-route-but-not-found-with-method', {\n          method: route.method\n        });\n      }\n\n      const routeIndex = this._routes.get(route.method).indexOf(route);\n\n      if (routeIndex > -1) {\n        this._routes.get(route.method).splice(routeIndex, 1);\n      } else {\n        throw new WorkboxError_mjs.WorkboxError('unregister-route-route-not-registered');\n      }\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * The router class exposed on the routing namespace.\n   * A single instance of this class is exposed because most users will only\n   * need one router, and this version offers the most features and flexibility.\n   */\n\n  class DefaultRouter extends Router {\n    /**\n     * The default router automatically adds fetch and cache message listeners.\n     */\n    constructor() {\n      super();\n      this.addFetchListener();\n      this.addCacheListener();\n    }\n    /**\n     * Easily register a RegExp, string, or function with a caching\n     * strategy to the Router.\n     *\n     * This method will generate a Route for you if needed and\n     * call [Router.registerRoute()]{@link\n     * workbox.routing.Router#registerRoute}.\n     *\n     * @param {\n     * RegExp|\n     * string|\n     * workbox.routing.Route~matchCallback|\n     * workbox.routing.Route\n     * } capture\n     * If the capture param is a `Route`, all other arguments will be ignored.\n     * @param {workbox.routing.Route~handlerCallback} handler A callback\n     * function that returns a Promise resulting in a Response.\n     * @param {string} [method='GET'] The HTTP method to match the Route\n     * against.\n     * @return {workbox.routing.Route} The generated `Route`(Useful for\n     * unregistering).\n     *\n     * @alias workbox.routing.registerRoute\n     */\n\n\n    registerRoute(capture, handler, method = 'GET') {\n      let route;\n\n      if (typeof capture === 'string') {\n        const captureUrl = new URL(capture, location);\n\n        {\n          if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n            throw new WorkboxError_mjs.WorkboxError('invalid-string', {\n              moduleName: 'workbox-routing',\n              className: 'DefaultRouter',\n              funcName: 'registerRoute',\n              paramName: 'capture'\n            });\n          } // We want to check if Express-style wildcards are in the pathname only.\n          // TODO: Remove this log message in v4.\n\n\n          const valueToCheck = capture.startsWith('http') ? captureUrl.pathname : capture; // See https://github.com/pillarjs/path-to-regexp#parameters\n\n          const wildcards = '[*:?+]';\n\n          if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n            logger_mjs.logger.debug(`The '$capture' parameter contains an Express-style wildcard ` + `character (${wildcards}). Strings are now always interpreted as ` + `exact matches; use a RegExp for partial or wildcard matches.`);\n          }\n        }\n\n        const matchCallback = ({\n          url\n        }) => {\n          {\n            if (url.pathname === captureUrl.pathname && url.origin !== captureUrl.origin) {\n              logger_mjs.logger.debug(`${capture} only partially matches the cross-origin URL ` + `${url}. This route will only handle cross-origin requests ` + `if they match the entire URL.`);\n            }\n          }\n\n          return url.href === captureUrl.href;\n        };\n\n        route = new Route(matchCallback, handler, method);\n      } else if (capture instanceof RegExp) {\n        route = new RegExpRoute(capture, handler, method);\n      } else if (typeof capture === 'function') {\n        route = new Route(capture, handler, method);\n      } else if (capture instanceof Route) {\n        route = capture;\n      } else {\n        throw new WorkboxError_mjs.WorkboxError('unsupported-route-type', {\n          moduleName: 'workbox-routing',\n          className: 'DefaultRouter',\n          funcName: 'registerRoute',\n          paramName: 'capture'\n        });\n      }\n\n      super.registerRoute(route);\n      return route;\n    }\n    /**\n     * Register a route that will return a precached file for a navigation\n     * request. This is useful for the\n     * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n     *\n     * This method will generate a\n     * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n     * and call\n     * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute}\n     * .\n     *\n     * @param {string} cachedAssetUrl\n     * @param {Object} [options]\n     * @param {string} [options.cacheName] Cache name to store and retrieve\n     * requests. Defaults to precache cache name provided by\n     * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n     * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n     * match, the route will not handle the request (even if a whitelist entry\n     * matches).\n     * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n     * match the URL's pathname and search parameter, the route will handle the\n     * request (assuming the blacklist doesn't match).\n     * @return {workbox.routing.NavigationRoute} Returns the generated\n     * Route.\n     *\n     * @alias workbox.routing.registerNavigationRoute\n     */\n\n\n    registerNavigationRoute(cachedAssetUrl, options = {}) {\n      {\n        assert_mjs.assert.isType(cachedAssetUrl, 'string', {\n          moduleName: 'workbox-routing',\n          className: '[default export]',\n          funcName: 'registerNavigationRoute',\n          paramName: 'cachedAssetUrl'\n        });\n      }\n\n      const cacheName = cacheNames_mjs.cacheNames.getPrecacheName(options.cacheName);\n\n      const handler = () => caches.match(cachedAssetUrl, {\n        cacheName\n      }).then(response => {\n        if (response) {\n          return response;\n        } // This shouldn't normally happen, but there are edge cases:\n        // https://github.com/GoogleChrome/workbox/issues/1441\n\n\n        throw new Error(`The cache ${cacheName} did not have an entry for ` + `${cachedAssetUrl}.`);\n      }).catch(error => {\n        // If there's either a cache miss, or the caches.match() call threw\n        // an exception, then attempt to fulfill the navigation request with\n        // a response from the network rather than leaving the user with a\n        // failed navigation.\n        {\n          logger_mjs.logger.debug(`Unable to respond to navigation request with ` + `cached response: ${error.message}. Falling back to network.`);\n        } // This might still fail if the browser is offline...\n\n\n        return fetch(cachedAssetUrl);\n      });\n\n      const route = new NavigationRoute(handler, {\n        whitelist: options.whitelist,\n        blacklist: options.blacklist\n      });\n      super.registerRoute(route);\n      return route;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  var publicAPI = /*#__PURE__*/Object.freeze({\n    DefaultRouter: DefaultRouter,\n    RegExpRoute: RegExpRoute,\n    Route: Route,\n    Router: Router,\n    NavigationRoute: NavigationRoute\n  });\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  {\n    assert_mjs.assert.isSwEnv('workbox-routing');\n  }\n\n  var defaultExport = new DefaultRouter();\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const finalExport = Object.assign(defaultExport, publicAPI);\n\n  return finalExport;\n\n}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private));\n"],"file":"workbox-routing.dev.js"}