{"version":3,"names":[],"mappings":"","sources":["packages/workbox-core/browser.mjs"],"sourcesContent":["this.workbox = this.workbox || {};\nthis.workbox.core = (function () {\n  'use strict';\n\n  try {\n    self.workbox.v['workbox:core:4.0.0-beta.0'] = 1;\n  } catch (e) {} // eslint-disable-line\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * The available log levels in Workbox: debug, log, warn, error and silent.\n   *\n   * @property {int} debug Prints all logs from Workbox. Useful for debugging.\n   * @property {int} log Prints console log, warn, error and groups. Default for\n   * debug builds.\n   * @property {int} warn Prints console warn, error and groups. Default for\n   * non-debug builds.\n   * @property {int} error Print console error and groups.\n   * @property {int} silent Force no logging from Workbox.\n   *\n   * @alias workbox.core.LOG_LEVELS\n   */\n\n  var LOG_LEVELS = {\n    debug: 0,\n    log: 1,\n    warn: 2,\n    error: 3,\n    silent: 4\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  // Related bug: https://bugs.webkit.org/show_bug.cgi?id=182754\n\n  const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n  const GREY = `#7f8c8d`;\n  const GREEN = `#2ecc71`;\n  const YELLOW = `#f39c12`;\n  const RED = `#c0392b`;\n  const BLUE = `#3498db`;\n\n  const getDefaultLogLevel = () => LOG_LEVELS.log;\n\n  let logLevel = getDefaultLogLevel();\n\n  const shouldPrint = minLevel => logLevel <= minLevel;\n\n  const setLoggerLevel = newLogLevel => logLevel = newLogLevel;\n\n  const getLoggerLevel = () => logLevel; // We always want groups to be logged unless logLevel is silent.\n\n\n  const groupLevel = LOG_LEVELS.error;\n\n  const _print = function (keyName, logArgs, levelColor) {\n    const logLevel = keyName.indexOf('group') === 0 ? groupLevel : LOG_LEVELS[keyName];\n\n    if (!shouldPrint(logLevel)) {\n      return;\n    }\n\n    if (!levelColor || keyName === 'groupCollapsed' && isSafari) {\n      console[keyName](...logArgs);\n      return;\n    }\n\n    const logPrefix = ['%cworkbox', `background: ${levelColor}; color: white; padding: 2px 0.5em; ` + `border-radius: 0.5em;`];\n    console[keyName](...logPrefix, ...logArgs);\n  };\n\n  const groupEnd = () => {\n    if (shouldPrint(groupLevel)) {\n      console.groupEnd();\n    }\n  };\n\n  const defaultExport = {\n    groupEnd,\n    unprefixed: {\n      groupEnd\n    }\n  };\n\n  const setupLogs = (keyName, color) => {\n    defaultExport[keyName] = (...args) => _print(keyName, args, color);\n\n    defaultExport.unprefixed[keyName] = (...args) => _print(keyName, args);\n  };\n\n  const levelToColor = {\n    debug: GREY,\n    log: GREEN,\n    warn: YELLOW,\n    error: RED,\n    groupCollapsed: BLUE\n  };\n  Object.keys(levelToColor).forEach(keyName => setupLogs(keyName, levelToColor[keyName]));\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  var messages = {\n    'invalid-value': ({\n      paramName,\n      validValueDescription,\n      value\n    }) => {\n      if (!paramName || !validValueDescription) {\n        throw new Error(`Unexpected input to 'invalid-value' error.`);\n      }\n\n      return `The '${paramName}' parameter was given a value with an ` + `unexpected value. ${validValueDescription} Received a value of ` + `${JSON.stringify(value)}.`;\n    },\n    'not-in-sw': ({\n      moduleName\n    }) => {\n      if (!moduleName) {\n        throw new Error(`Unexpected input to 'not-in-sw' error.`);\n      }\n\n      return `The '${moduleName}' must be used in a service worker.`;\n    },\n    'not-an-array': ({\n      moduleName,\n      className,\n      funcName,\n      paramName\n    }) => {\n      if (!moduleName || !className || !funcName || !paramName) {\n        throw new Error(`Unexpected input to 'not-an-array' error.`);\n      }\n\n      return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className}.${funcName}()' must be an array.`;\n    },\n    'incorrect-type': ({\n      expectedType,\n      paramName,\n      moduleName,\n      className,\n      funcName\n    }) => {\n      if (!expectedType || !paramName || !moduleName || !funcName) {\n        throw new Error(`Unexpected input to 'incorrect-type' error.`);\n      }\n\n      return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className ? className + '.' : ''}` + `${funcName}()' must be of type ${expectedType}.`;\n    },\n    'incorrect-class': ({\n      expectedClass,\n      paramName,\n      moduleName,\n      className,\n      funcName,\n      isReturnValueProblem\n    }) => {\n      if (!expectedClass || !moduleName || !funcName) {\n        throw new Error(`Unexpected input to 'incorrect-class' error.`);\n      }\n\n      if (isReturnValueProblem) {\n        return `The return value from ` + `'${moduleName}.${className ? className + '.' : ''}${funcName}()' ` + `must be an instance of class ${expectedClass.name}.`;\n      }\n\n      return `The parameter '${paramName}' passed into ` + `'${moduleName}.${className ? className + '.' : ''}${funcName}()' ` + `must be an instance of class ${expectedClass.name}.`;\n    },\n    'missing-a-method': ({\n      expectedMethod,\n      paramName,\n      moduleName,\n      className,\n      funcName\n    }) => {\n      if (!expectedMethod || !paramName || !moduleName || !className || !funcName) {\n        throw new Error(`Unexpected input to 'missing-a-method' error.`);\n      }\n\n      return `${moduleName}.${className}.${funcName}() expected the ` + `'${paramName}' parameter to expose a '${expectedMethod}' method.`;\n    },\n    'add-to-cache-list-unexpected-type': ({\n      entry\n    }) => {\n      return `An unexpected entry was passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' The entry ` + `'${JSON.stringify(entry)}' isn't supported. You must supply an array of ` + `strings with one or more characters, objects with a url property or ` + `Request objects.`;\n    },\n    'add-to-cache-list-conflicting-entries': ({\n      firstEntry,\n      secondEntry\n    }) => {\n      if (!firstEntry || !secondEntry) {\n        throw new Error(`Unexpected input to ` + `'add-to-cache-list-duplicate-entries' error.`);\n      }\n\n      return `Two of the entries passed to ` + `'workbox-precaching.PrecacheController.addToCacheList()' had matching ` + `URLs but different revision details. This means workbox-precaching ` + `is unable to determine cache the asset correctly. Please remove one ` + `of the entries.`;\n    },\n    'plugin-error-request-will-fetch': ({\n      thrownError\n    }) => {\n      if (!thrownError) {\n        throw new Error(`Unexpected input to ` + `'plugin-error-request-will-fetch', error.`);\n      }\n\n      return `An error was thrown by a plugins 'requestWillFetch()' method. ` + `The thrown error message was: '${thrownError.message}'.`;\n    },\n    'invalid-cache-name': ({\n      cacheNameId,\n      value\n    }) => {\n      if (!cacheNameId) {\n        throw new Error(`Expected a 'cacheNameId' for error 'invalid-cache-name'`);\n      }\n\n      return `You must provide a name containing at least one character for ` + `setCacheDeatils({${cacheNameId}: '...'}). Received a value of ` + `'${JSON.stringify(value)}'`;\n    },\n    'unregister-route-but-not-found-with-method': ({\n      method\n    }) => {\n      if (!method) {\n        throw new Error(`Unexpected input to ` + `'unregister-route-but-not-found-with-method' error.`);\n      }\n\n      return `The route you're trying to unregister was not  previously ` + `registered for the method type '${method}'.`;\n    },\n    'unregister-route-route-not-registered': () => {\n      return `The route you're trying to unregister was not previously ` + `registered.`;\n    },\n    'queue-replay-failed': ({\n      name\n    }) => {\n      return `Replaying the background sync queue '${name}' failed.`;\n    },\n    'duplicate-queue-name': ({\n      name\n    }) => {\n      return `The Queue name '${name}' is already being used. ` + `All instances of backgroundSync.Queue must be given unique names.`;\n    },\n    'expired-test-without-max-age': ({\n      methodName,\n      paramName\n    }) => {\n      return `The '${methodName}()' method can only be used when the ` + `'${paramName}' is used in the constructor.`;\n    },\n    'unsupported-route-type': ({\n      moduleName,\n      className,\n      funcName,\n      paramName\n    }) => {\n      return `The supplied '${paramName}' parameter was an unsupported type. ` + `Please check the docs for ${moduleName}.${className}.${funcName} for ` + `valid input types.`;\n    },\n    'not-array-of-class': ({\n      value,\n      expectedClass,\n      moduleName,\n      className,\n      funcName,\n      paramName\n    }) => {\n      return `The supplied '${paramName}' parameter must be an array of ` + `'${expectedClass}' objects. Received '${JSON.stringify(value)},'. ` + `Please check the call to ${moduleName}.${className}.${funcName}() ` + `to fix the issue.`;\n    },\n    'max-entries-or-age-required': ({\n      moduleName,\n      className,\n      funcName\n    }) => {\n      return `You must define either config.maxEntries or config.maxAgeSeconds` + `in ${moduleName}.${className}.${funcName}`;\n    },\n    'statuses-or-headers-required': ({\n      moduleName,\n      className,\n      funcName\n    }) => {\n      return `You must define either config.statuses or config.headers` + `in ${moduleName}.${className}.${funcName}`;\n    },\n    'invalid-string': ({\n      moduleName,\n      className,\n      funcName,\n      paramName\n    }) => {\n      if (!paramName || !moduleName || !className || !funcName) {\n        throw new Error(`Unexpected input to 'invalid-string' error.`);\n      }\n\n      return `When using strings, the '${paramName}' parameter must start with ` + `'http' (for cross-origin matches) or '/' (for same-origin matches). ` + `Please see the docs for ${moduleName}.${className}.${funcName}() for ` + `more info.`;\n    },\n    'channel-name-required': () => {\n      return `You must provide a channelName to construct a ` + `BroadcastCacheUpdate instance.`;\n    },\n    'invalid-responses-are-same-args': () => {\n      return `The arguments passed into responsesAreSame() appear to be ` + `invalid. Please ensure valid Responses are used.`;\n    },\n    'expire-custom-caches-only': () => {\n      return `You must provide a 'cacheName' property when using the ` + `expiration plugin with a runtime caching strategy.`;\n    },\n    'unit-must-be-bytes': ({\n      normalizedRangeHeader\n    }) => {\n      if (!normalizedRangeHeader) {\n        throw new Error(`Unexpected input to 'unit-must-be-bytes' error.`);\n      }\n\n      return `The 'unit' portion of the Range header must be set to 'bytes'. ` + `The Range header provided was \"${normalizedRangeHeader}\"`;\n    },\n    'single-range-only': ({\n      normalizedRangeHeader\n    }) => {\n      if (!normalizedRangeHeader) {\n        throw new Error(`Unexpected input to 'single-range-only' error.`);\n      }\n\n      return `Multiple ranges are not supported. Please use a  single start ` + `value, and optional end value. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n    },\n    'invalid-range-values': ({\n      normalizedRangeHeader\n    }) => {\n      if (!normalizedRangeHeader) {\n        throw new Error(`Unexpected input to 'invalid-range-values' error.`);\n      }\n\n      return `The Range header is missing both start and end values. At least ` + `one of those values is needed. The Range header provided was ` + `\"${normalizedRangeHeader}\"`;\n    },\n    'no-range-header': () => {\n      return `No Range header was found in the Request provided.`;\n    },\n    'range-not-satisfiable': ({\n      size,\n      start,\n      end\n    }) => {\n      return `The start (${start}) and end (${end}) values in the Range are ` + `not satisfiable by the cached response, which is ${size} bytes.`;\n    },\n    'attempt-to-cache-non-get-request': ({\n      url,\n      method\n    }) => {\n      return `Unable to cache '${url}' because it is a '${method}' request and ` + `only 'GET' requests can be cached.`;\n    },\n    'cache-put-with-no-response': ({\n      url\n    }) => {\n      return `There was an attempt to cache '${url}' but the response was not ` + `defined.`;\n    },\n    'no-response': ({\n      url,\n      error\n    }) => {\n      let message = `The strategy could not generate a response for '${url}'.`;\n\n      if (error) {\n        message += ` The underlying error is ${error}.`;\n      }\n\n      return message;\n    },\n    'bad-precaching-response': ({\n      url,\n      status\n    }) => {\n      return `The precaching request for '${url}' failed with an HTTP ` + `status of ${status}.`;\n    }\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  const generatorFunction = (code, ...args) => {\n    const message = messages[code];\n\n    if (!message) {\n      throw new Error(`Unable to find message for code '${code}'.`);\n    }\n\n    return message(...args);\n  };\n\n  const exportedValue = generatorFunction;\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Workbox errors should be thrown with this class.\n   * This allows use to ensure the type easily in tests,\n   * helps developers identify errors from workbox\n   * easily and allows use to optimise error\n   * messages correctly.\n   *\n   * @private\n   */\n\n  class WorkboxError extends Error {\n    /**\n     *\n     * @param {string} errorCode The error code that\n     * identifies this particular error.\n     * @param {Object=} details Any relevant arguments\n     * that will help developers identify issues should\n     * be added as a key on the context object.\n     */\n    constructor(errorCode, details) {\n      let message = exportedValue(errorCode, details);\n      super(message);\n      this.name = errorCode;\n      this.details = details;\n    }\n\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /*\n   * This method returns true if the current context is a service worker.\n   */\n\n  const isSwEnv = moduleName => {\n    if (!('ServiceWorkerGlobalScope' in self)) {\n      throw new WorkboxError('not-in-sw', {\n        moduleName\n      });\n    }\n  };\n  /*\n   * This method throws if the supplied value is not an array.\n   * The destructed values are required to produce a meaningful error for users.\n   * The destructed and restructured object is so it's clear what is\n   * needed.\n   */\n\n\n  const isArray = (value, {\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    if (!Array.isArray(value)) {\n      throw new WorkboxError('not-an-array', {\n        moduleName,\n        className,\n        funcName,\n        paramName\n      });\n    }\n  };\n\n  const hasMethod = (object, expectedMethod, {\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    const type = typeof object[expectedMethod];\n\n    if (type !== 'function') {\n      throw new WorkboxError('missing-a-method', {\n        paramName,\n        expectedMethod,\n        moduleName,\n        className,\n        funcName\n      });\n    }\n  };\n\n  const isType = (object, expectedType, {\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    if (typeof object !== expectedType) {\n      throw new WorkboxError('incorrect-type', {\n        paramName,\n        expectedType,\n        moduleName,\n        className,\n        funcName\n      });\n    }\n  };\n\n  const isInstance = (object, expectedClass, {\n    moduleName,\n    className,\n    funcName,\n    paramName,\n    isReturnValueProblem\n  }) => {\n    if (!(object instanceof expectedClass)) {\n      throw new WorkboxError('incorrect-class', {\n        paramName,\n        expectedClass,\n        moduleName,\n        className,\n        funcName,\n        isReturnValueProblem\n      });\n    }\n  };\n\n  const isOneOf = (value, validValues, {\n    paramName\n  }) => {\n    if (!validValues.includes(value)) {\n      throw new WorkboxError('invalid-value', {\n        paramName,\n        value,\n        validValueDescription: `Valid values are ${JSON.stringify(validValues)}.`\n      });\n    }\n  };\n\n  const isArrayOfClass = (value, expectedClass, {\n    moduleName,\n    className,\n    funcName,\n    paramName\n  }) => {\n    const error = new WorkboxError('not-array-of-class', {\n      value,\n      expectedClass,\n      moduleName,\n      className,\n      funcName,\n      paramName\n    });\n\n    if (!Array.isArray(value)) {\n      throw error;\n    }\n\n    for (let item of value) {\n      if (!(item instanceof expectedClass)) {\n        throw error;\n      }\n    }\n  };\n\n  const finalAssertExports = {\n    hasMethod,\n    isArray,\n    isInstance,\n    isOneOf,\n    isSwEnv,\n    isType,\n    isArrayOfClass\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const callbacks = new Set();\n  /**\n   * Adds a function to the set of callbacks that will be executed when there's\n   * a quota error.\n   *\n   * @param {Function} callback\n   * @memberof workbox.core\n   */\n\n  function registerQuotaErrorCallback(callback) {\n    {\n      finalAssertExports.isType(callback, 'function', {\n        moduleName: 'workbox-core',\n        funcName: 'register',\n        paramName: 'callback'\n      });\n    }\n\n    callbacks.add(callback);\n\n    {\n      defaultExport.log('Registered a callback to respond to quota errors.', callback);\n    }\n  }\n  /**\n   * Runs all of the callback functions, one at a time sequentially, in the order\n   * in which they were registered.\n   *\n   * @memberof workbox.core\n   * @private\n   */\n\n\n  async function executeQuotaErrorCallbacks() {\n    {\n      defaultExport.log(`About to run ${callbacks.size} callbacks to clean up caches.`);\n    }\n\n    for (const callback of callbacks) {\n      await callback();\n\n      {\n        defaultExport.log(callback, 'is complete.');\n      }\n    }\n\n    {\n      defaultExport.log('Finished running callbacks.');\n    }\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * A class that wraps common IndexedDB functionality in a promise-based API.\n   * It exposes all the underlying power and functionality of IndexedDB, but\n   * wraps the most commonly used features in a way that's much simpler to use.\n   *\n   * @private\n   */\n\n  class DBWrapper {\n    /**\n     * @param {string} name\n     * @param {number} version\n     * @param {Object=} [callback]\n     * @param {!Function} [callbacks.onupgradeneeded]\n     * @param {!Function} [callbacks.onversionchange] Defaults to\n     *     DBWrapper.prototype._onversionchange when not specified.\n     */\n    constructor(name, version, {\n      onupgradeneeded,\n      onversionchange = this._onversionchange\n    } = {}) {\n      this._name = name;\n      this._version = version;\n      this._onupgradeneeded = onupgradeneeded;\n      this._onversionchange = onversionchange; // If this is null, it means the database isn't open.\n\n      this._db = null;\n    }\n    /**\n     * Returns the IDBDatabase instance (not normally needed).\n     */\n\n\n    get db() {\n      return this._db;\n    }\n    /**\n     * Opens a connected to an IDBDatabase, invokes any onupgradedneeded\n     * callback, and added an onversionchange callback to the database.\n     *\n     * @return {IDBDatabase}\n     */\n\n\n    async open() {\n      if (this._db) return;\n      this._db = await new Promise((resolve, reject) => {\n        // This flag is flipped to true if the timeout callback runs prior\n        // to the request failing or succeeding. Note: we use a timeout instead\n        // of an onblocked handler since there are cases where onblocked will\n        // never never run. A timeout better handles all possible scenarios:\n        // https://github.com/w3c/IndexedDB/issues/223\n        let openRequestTimedOut = false;\n        setTimeout(() => {\n          openRequestTimedOut = true;\n          reject(new Error('The open request was blocked and timed out'));\n        }, this.OPEN_TIMEOUT);\n        const openRequest = indexedDB.open(this._name, this._version);\n\n        openRequest.onerror = () => reject(openRequest.error);\n\n        openRequest.onupgradeneeded = evt => {\n          if (openRequestTimedOut) {\n            openRequest.transaction.abort();\n            evt.target.result.close();\n          } else if (this._onupgradeneeded) {\n            this._onupgradeneeded(evt);\n          }\n        };\n\n        openRequest.onsuccess = ({\n          target\n        }) => {\n          const db = target.result;\n\n          if (openRequestTimedOut) {\n            db.close();\n          } else {\n            db.onversionchange = this._onversionchange;\n            resolve(db);\n          }\n        };\n      });\n      return this;\n    }\n    /**\n     * Polyfills the native `getKey()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @return {Array}\n     */\n\n\n    async getKey(storeName, query) {\n      return (await this.getAllKeys(storeName, query, 1))[0];\n    }\n    /**\n     * Polyfills the native `getAll()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     */\n\n\n    async getAll(storeName, query, count) {\n      return await this.getAllMatching(storeName, {\n        query,\n        count\n      });\n    }\n    /**\n     * Polyfills the native `getAllKeys()` method. Note, this is overridden at\n     * runtime if the browser supports the native method.\n     *\n     * @param {string} storeName\n     * @param {*} query\n     * @param {number} count\n     * @return {Array}\n     */\n\n\n    async getAllKeys(storeName, query, count) {\n      return (await this.getAllMatching(storeName, {\n        query,\n        count,\n        includeKeys: true\n      })).map(({\n        key\n      }) => key);\n    }\n    /**\n     * Supports flexible lookup in an object store by specifying an index,\n     * query, direction, and count. This method returns an array of objects\n     * with the signature .\n     *\n     * @param {string} storeName\n     * @param {Object} [opts]\n     * @param {string} [opts.index] The index to use (if specified).\n     * @param {*} [opts.query]\n     * @param {IDBCursorDirection} [opts.direction]\n     * @param {number} [opts.count] The max number of results to return.\n     * @param {boolean} [opts.includeKeys] When true, the structure of the\n     *     returned objects is changed from an array of values to an array of\n     *     objects in the form {key, primaryKey, value}.\n     * @return {Array}\n     */\n\n\n    async getAllMatching(storeName, {\n      index,\n      query = null,\n      // IE errors if query === `undefined`.\n      direction = 'next',\n      count,\n      includeKeys\n    } = {}) {\n      return await this.transaction([storeName], 'readonly', (txn, done) => {\n        const store = txn.objectStore(storeName);\n        const target = index ? store.index(index) : store;\n        const results = [];\n\n        target.openCursor(query, direction).onsuccess = ({\n          target\n        }) => {\n          const cursor = target.result;\n\n          if (cursor) {\n            const {\n              primaryKey,\n              key,\n              value\n            } = cursor;\n            results.push(includeKeys ? {\n              primaryKey,\n              key,\n              value\n            } : value);\n\n            if (count && results.length >= count) {\n              done(results);\n            } else {\n              cursor.continue();\n            }\n          } else {\n            done(results);\n          }\n        };\n      });\n    }\n    /**\n     * Accepts a list of stores, a transaction type, and a callback and\n     * performs a transaction. A promise is returned that resolves to whatever\n     * value the callback chooses. The callback holds all the transaction logic\n     * and is invoked with two arguments:\n     *   1. The IDBTransaction object\n     *   2. A `done` function, that's used to resolve the promise when\n     *      when the transaction is done, if passed a value, the promise is\n     *      resolved to that value.\n     *\n     * @param {Array<string>} storeNames An array of object store names\n     *     involved in the transaction.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {!Function} callback\n     * @return {*} The result of the transaction ran by the callback.\n     */\n\n\n    async transaction(storeNames, type, callback) {\n      await this.open();\n      return await new Promise((resolve, reject) => {\n        const txn = this._db.transaction(storeNames, type);\n\n        txn.onabort = ({\n          target\n        }) => reject(target.error);\n\n        txn.oncomplete = () => resolve();\n\n        callback(txn, value => resolve(value));\n      });\n    }\n    /**\n     * Delegates async to a native IDBObjectStore method.\n     *\n     * @param {string} method The method name.\n     * @param {string} storeName The object store name.\n     * @param {string} type Can be `readonly` or `readwrite`.\n     * @param {...*} args The list of args to pass to the native method.\n     * @return {*} The result of the transaction.\n     */\n\n\n    async _call(method, storeName, type, ...args) {\n      const callback = (txn, done) => {\n        txn.objectStore(storeName)[method](...args).onsuccess = ({\n          target\n        }) => {\n          done(target.result);\n        };\n      };\n\n      return await this.transaction([storeName], type, callback);\n    }\n    /**\n     * The default onversionchange handler, which closes the database so other\n     * connections can open without being blocked.\n     */\n\n\n    _onversionchange() {\n      this.close();\n    }\n    /**\n     * Closes the connection opened by `DBWrapper.open()`. Generally this method\n     * doesn't need to be called since:\n     *   1. It's usually better to keep a connection open since opening\n     *      a new connection is somewhat slow.\n     *   2. Connections are automatically closed when the reference is\n     *      garbage collected.\n     * The primary use case for needing to close a connection is when another\n     * reference (typically in another tab) needs to upgrade it and would be\n     * blocked by the current, open connection.\n     */\n\n\n    close() {\n      if (this._db) this._db.close();\n    }\n\n  } // Exposed to let users modify the default timeout on a per-instance\n  // or global basis.\n\n  DBWrapper.prototype.OPEN_TIMEOUT = 2000; // Wrap native IDBObjectStore methods according to their mode.\n\n  const methodsToWrap = {\n    'readonly': ['get', 'count', 'getKey', 'getAll', 'getAllKeys'],\n    'readwrite': ['add', 'put', 'clear', 'delete']\n  };\n\n  for (const [mode, methods] of Object.entries(methodsToWrap)) {\n    for (const method of methods) {\n      if (method in IDBObjectStore.prototype) {\n        // Don't use arrow functions here since we're outside of the class.\n        DBWrapper.prototype[method] = async function (storeName, ...args) {\n          return await this._call(method, storeName, mode, ...args);\n        };\n      }\n    }\n  }\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Deletes the database.\n   * Note: this is exported separately from the DBWrapper module because most\n   * usages of IndexedDB in workbox dont need deleting, and this way it can be\n   * reused in tests to delete databases without creating DBWrapper instances.\n   *\n   * @param {string} name The database name.\n   * @private\n   */\n\n  const deleteDatabase = async name => {\n    await new Promise((resolve, reject) => {\n      const request = indexedDB.deleteDatabase(name);\n\n      request.onerror = ({\n        target\n      }) => {\n        reject(target.error);\n      };\n\n      request.onblocked = () => {\n        reject(new Error('Delete blocked'));\n      };\n\n      request.onsuccess = () => {\n        resolve();\n      };\n    });\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Handles running a series of migration functions to upgrade an IndexedDB\n   * database in a `versionchange` event.\n   *\n   * @private\n   * @param {IDBVersionChangeEvent} event\n   * @param {Object<string, Function>} migrationFunctions\n   */\n\n  const migrateDb = (event, migrationFunctions) => {\n    let {\n      oldVersion,\n      newVersion\n    } = event; // Call all `migrationFunctions` values between oldVersion and newVersion.\n\n    const migrate = oldVersion => {\n      const next = () => {\n        ++oldVersion;\n\n        if (oldVersion <= newVersion) {\n          migrate(oldVersion);\n        }\n      };\n\n      const migrationFunction = migrationFunctions[`v${oldVersion}`];\n\n      if (typeof migrationFunction === 'function') {\n        migrationFunction(next);\n      } else {\n        next();\n      }\n    };\n\n    migrate(oldVersion);\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const _cacheNameDetails = {\n    prefix: 'workbox',\n    suffix: self.registration.scope,\n    googleAnalytics: 'googleAnalytics',\n    precache: 'precache',\n    runtime: 'runtime'\n  };\n\n  const _createCacheName = cacheName => {\n    return [_cacheNameDetails.prefix, cacheName, _cacheNameDetails.suffix].filter(value => value.length > 0).join('-');\n  };\n\n  const cacheNames = {\n    updateDetails: details => {\n      Object.keys(_cacheNameDetails).forEach(key => {\n        if (typeof details[key] !== 'undefined') {\n          _cacheNameDetails[key] = details[key];\n        }\n      });\n    },\n    getGoogleAnalyticsName: userCacheName => {\n      return userCacheName || _createCacheName(_cacheNameDetails.googleAnalytics);\n    },\n    getPrecacheName: userCacheName => {\n      return userCacheName || _createCacheName(_cacheNameDetails.precache);\n    },\n    getRuntimeName: userCacheName => {\n      return userCacheName || _createCacheName(_cacheNameDetails.runtime);\n    }\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  var pluginEvents = {\n    CACHE_DID_UPDATE: 'cacheDidUpdate',\n    CACHE_WILL_UPDATE: 'cacheWillUpdate',\n    CACHED_RESPONSE_WILL_BE_USED: 'cachedResponseWillBeUsed',\n    FETCH_DID_FAIL: 'fetchDidFail',\n    REQUEST_WILL_FETCH: 'requestWillFetch'\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  var pluginUtils = {\n    filter: (plugins, callbackname) => {\n      return plugins.filter(plugin => callbackname in plugin);\n    }\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  const getFriendlyURL = url => {\n    const urlObj = new URL(url, location);\n\n    if (urlObj.origin === location.origin) {\n      return urlObj.pathname;\n    }\n\n    return urlObj.href;\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Wrapper around cache.put().\n   *\n   * Will call `cacheDidUpdate` on plugins if the cache was updated.\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName\n   * @param {Request} options.request\n   * @param {Response} options.response\n   * @param {Event} [options.event]\n   * @param {Array<Object>} [options.plugins=[]]\n   *\n   * @private\n   * @memberof module:workbox-core\n   */\n\n  const putWrapper = async ({\n    cacheName,\n    request,\n    response,\n    event,\n    plugins = []\n  } = {}) => {\n    if (!response) {\n      {\n        defaultExport.error(`Cannot cache non-existent response for ` + `'${getFriendlyURL(request.url)}'.`);\n      }\n\n      throw new WorkboxError('cache-put-with-no-response', {\n        url: getFriendlyURL(request.url)\n      });\n    }\n\n    let responseToCache = await _isResponseSafeToCache({\n      request,\n      response,\n      event,\n      plugins\n    });\n\n    if (!responseToCache) {\n      {\n        defaultExport.debug(`Response '${getFriendlyURL(request.url)}' will not be ` + `cached.`, responseToCache);\n      }\n\n      return;\n    }\n\n    {\n      if (responseToCache.method && responseToCache.method !== 'GET') {\n        throw new WorkboxError('attempt-to-cache-non-get-request', {\n          url: getFriendlyURL(request.url),\n          method: responseToCache.method\n        });\n      }\n    }\n\n    const cache = await caches.open(cacheName);\n    const updatePlugins = pluginUtils.filter(plugins, pluginEvents.CACHE_DID_UPDATE);\n    let oldResponse = updatePlugins.length > 0 ? await matchWrapper({\n      cacheName,\n      request\n    }) : null;\n\n    {\n      defaultExport.debug(`Updating the '${cacheName}' cache with a new Response for ` + `${getFriendlyURL(request.url)}.`);\n    }\n\n    try {\n      await cache.put(request, responseToCache);\n    } catch (error) {\n      // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n      if (error.name === 'QuotaExceededError') {\n        await executeQuotaErrorCallbacks();\n      }\n\n      throw error;\n    }\n\n    for (let plugin of updatePlugins) {\n      await plugin[pluginEvents.CACHE_DID_UPDATE].call(plugin, {\n        cacheName,\n        request,\n        event,\n        oldResponse,\n        newResponse: responseToCache\n      });\n    }\n  };\n  /**\n   * This is a wrapper around cache.match().\n   *\n   * @param {Object} options\n   * @param {string} options.cacheName Name of the cache to match against.\n   * @param {Request} options.request The Request that will be used to look up\n   *     cache entries.\n   * @param {Event} [options.event] The event that propted the action.\n   * @param {Object} [options.matchOptions] Options passed to cache.match().\n   * @param {Array<Object>} [options.plugins=[]] Array of plugins.\n   * @return {Response} A cached response if available.\n   *\n   * @private\n   * @memberof module:workbox-core\n   */\n\n\n  const matchWrapper = async ({\n    cacheName,\n    request,\n    event,\n    matchOptions,\n    plugins = []\n  }) => {\n    const cache = await caches.open(cacheName);\n    let cachedResponse = await cache.match(request, matchOptions);\n\n    {\n      if (cachedResponse) {\n        defaultExport.debug(`Found a cached response in '${cacheName}'.`);\n      } else {\n        defaultExport.debug(`No cached response found in '${cacheName}'.`);\n      }\n    }\n\n    for (let plugin of plugins) {\n      if (pluginEvents.CACHED_RESPONSE_WILL_BE_USED in plugin) {\n        cachedResponse = await plugin[pluginEvents.CACHED_RESPONSE_WILL_BE_USED].call(plugin, {\n          cacheName,\n          request,\n          event,\n          matchOptions,\n          cachedResponse\n        });\n\n        {\n          if (cachedResponse) {\n            finalAssertExports.isInstance(cachedResponse, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n              isReturnValueProblem: true\n            });\n          }\n        }\n      }\n    }\n\n    return cachedResponse;\n  };\n  /**\n   * This method will call cacheWillUpdate on the available plugins (or use\n   * response.ok) to determine if the Response is safe and valid to cache.\n   *\n   * @param {Object} options\n   * @param {Request} options.request\n   * @param {Response} options.response\n   * @param {Event} [options.event]\n   * @param {Array<Object>} [options.plugins=[]]\n   * @return {Promise<Response>}\n   *\n   * @private\n   * @memberof module:workbox-core\n   */\n\n\n  const _isResponseSafeToCache = async ({\n    request,\n    response,\n    event,\n    plugins\n  }) => {\n    let responseToCache = response;\n    let pluginsUsed = false;\n\n    for (let plugin of plugins) {\n      if (pluginEvents.CACHE_WILL_UPDATE in plugin) {\n        pluginsUsed = true;\n        responseToCache = await plugin[pluginEvents.CACHE_WILL_UPDATE].call(plugin, {\n          request,\n          response: responseToCache,\n          event\n        });\n\n        {\n          if (responseToCache) {\n            finalAssertExports.isInstance(responseToCache, Response, {\n              moduleName: 'Plugin',\n              funcName: pluginEvents.CACHE_WILL_UPDATE,\n              isReturnValueProblem: true\n            });\n          }\n        }\n\n        if (!responseToCache) {\n          break;\n        }\n      }\n    }\n\n    if (!pluginsUsed) {\n      {\n        if (!responseToCache.ok) {\n          if (responseToCache.status === 0) {\n            defaultExport.warn(`The response for '${request.url}' is an opaque ` + `response. The caching strategy that you're using will not ` + `cache opaque responses by default.`);\n          } else {\n            defaultExport.debug(`The response for '${request.url}' returned ` + `a status code of '${response.status}' and won't be cached as a ` + `result.`);\n          }\n        }\n      }\n\n      responseToCache = responseToCache.ok ? responseToCache : null;\n    }\n\n    return responseToCache ? responseToCache : null;\n  };\n\n  const cacheWrapper = {\n    put: putWrapper,\n    match: matchWrapper\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Wrapper around the fetch API.\n   *\n   * Will call requestWillFetch on available plugins.\n   *\n   * @param {Object} options\n   * @param {Request|string} options.request\n   * @param {Object} [options.fetchOptions]\n   * @param {Event} [options.event]\n   * @param {Array<Object>} [options.plugins=[]]\n   * @return {Promise<Response>}\n   *\n   * @private\n   * @memberof module:workbox-core\n   */\n\n  const wrappedFetch = async ({\n    request,\n    fetchOptions,\n    event,\n    plugins = []\n  }) => {\n    // We *should* be able to call `await event.preloadResponse` even if it's\n    // undefined, but for some reason, doing so leads to errors in our Node unit\n    // tests. To work around that, explicitly check preloadResponse's value first.\n    if (event && event.preloadResponse) {\n      const possiblePreloadResponse = await event.preloadResponse;\n\n      if (possiblePreloadResponse) {\n        {\n          defaultExport.log(`Using a preloaded navigation response for ` + `'${getFriendlyURL(request.url)}'`);\n        }\n\n        return possiblePreloadResponse;\n      }\n    }\n\n    if (typeof request === 'string') {\n      request = new Request(request);\n    }\n\n    {\n      finalAssertExports.isInstance(request, Request, {\n        paramName: request,\n        expectedClass: 'Request',\n        moduleName: 'workbox-core',\n        className: 'fetchWrapper',\n        funcName: 'wrappedFetch'\n      });\n    }\n\n    const failedFetchPlugins = pluginUtils.filter(plugins, pluginEvents.FETCH_DID_FAIL); // If there is a fetchDidFail plugin, we need to save a clone of the\n    // original request before it's either modified by a requestWillFetch\n    // plugin or before the original request's body is consumed via fetch().\n\n    const originalRequest = failedFetchPlugins.length > 0 ? request.clone() : null;\n\n    try {\n      for (let plugin of plugins) {\n        if (pluginEvents.REQUEST_WILL_FETCH in plugin) {\n          request = await plugin[pluginEvents.REQUEST_WILL_FETCH].call(plugin, {\n            request: request.clone(),\n            event\n          });\n\n          {\n            if (request) {\n              finalAssertExports.isInstance(request, Request, {\n                moduleName: 'Plugin',\n                funcName: pluginEvents.CACHED_RESPONSE_WILL_BE_USED,\n                isReturnValueProblem: true\n              });\n            }\n          }\n        }\n      }\n    } catch (err) {\n      throw new WorkboxError('plugin-error-request-will-fetch', {\n        thrownError: err\n      });\n    } // The request can be altered by plugins with `requestWillFetch` making\n    // the original request (Most likely from a `fetch` event) to be different\n    // to the Request we make. Pass both to `fetchDidFail` to aid debugging.\n\n\n    const pluginFilteredRequest = request.clone();\n\n    try {\n      const fetchResponse = await fetch(request, fetchOptions);\n\n      {\n        defaultExport.debug(`Network request for ` + `'${getFriendlyURL(request.url)}' returned a response with ` + `status '${fetchResponse.status}'.`);\n      }\n\n      return fetchResponse;\n    } catch (error) {\n      {\n        defaultExport.error(`Network request for ` + `'${getFriendlyURL(request.url)}' threw an error.`, error);\n      }\n\n      for (let plugin of failedFetchPlugins) {\n        await plugin[pluginEvents.FETCH_DID_FAIL].call(plugin, {\n          error,\n          event,\n          originalRequest: originalRequest.clone(),\n          request: pluginFilteredRequest.clone()\n        });\n      }\n\n      throw error;\n    }\n  };\n\n  const fetchWrapper = {\n    fetch: wrappedFetch\n  };\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n\n  var _private = /*#__PURE__*/Object.freeze({\n    DBWrapper: DBWrapper,\n    deleteDatabase: deleteDatabase,\n    migrateDb: migrateDb,\n    WorkboxError: WorkboxError,\n    assert: finalAssertExports,\n    cacheNames: cacheNames,\n    cacheWrapper: cacheWrapper,\n    fetchWrapper: fetchWrapper,\n    getFriendlyURL: getFriendlyURL,\n    logger: defaultExport\n  });\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * Logs a warning to the user recommending changing\n   * to max-age=0 or no-cache.\n   *\n   * @param {string} cacheControlHeader\n   *\n   * @private\n   */\n\n  function showWarning(cacheControlHeader) {\n    const docsUrl = 'https://developers.google.com/web/tools/workbox/guides/service-worker-checklist#cache-control_of_your_service_worker_file';\n    defaultExport.warn(`You are setting a 'cache-control' header of ` + `'${cacheControlHeader}' on your service worker file. This should be ` + `set to 'max-age=0' or 'no-cache' to ensure the latest service worker ` + `is served to your users. Learn more here: ${docsUrl}`);\n  }\n  /**\n   * Checks for cache-control header on SW file and\n   * warns the developer if it exists with a value\n   * other than max-age=0 or no-cache.\n   *\n   * @return {Promise}\n   * @private\n   */\n\n\n  function checkSWFileCacheHeaders() {\n    // This is wrapped as an iife to allow async/await while making\n    //  rollup exclude it in builds.\n    return (async () => {\n      try {\n        const swFile = self.location.href;\n        const response = await fetch(swFile);\n\n        if (!response.ok) {\n          // Response failed so nothing we can check;\n          return;\n        }\n\n        if (!response.headers.has('cache-control')) {\n          // No cache control header.\n          return;\n        }\n\n        const cacheControlHeader = response.headers.get('cache-control');\n        const maxAgeResult = /max-age\\s*=\\s*(\\d*)/g.exec(cacheControlHeader);\n\n        if (maxAgeResult) {\n          if (parseInt(maxAgeResult[1], 10) === 0) {\n            return;\n          }\n        }\n\n        if (cacheControlHeader.indexOf('no-cache') !== -1) {\n          return;\n        }\n\n        if (cacheControlHeader.indexOf('no-store') !== -1) {\n          return;\n        }\n\n        showWarning(cacheControlHeader);\n      } catch (err) {// NOOP\n      }\n    })();\n  }\n\n  const finalCheckSWFileCacheHeaders = checkSWFileCacheHeaders;\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  /**\n   * This class is never exposed publicly. Inidividual methods are exposed\n   * using jsdoc alias commands.\n   *\n   * @memberof workbox.core\n   * @private\n   */\n\n  class WorkboxCore {\n    /**\n     * You should not instantiate this object directly.\n     *\n     * @private\n     */\n    constructor() {\n      // Give our version strings something to hang off of.\n      try {\n        self.workbox.v = self.workbox.v || {};\n      } catch (err) {} // NOOP\n      // A WorkboxCore instance must be exported before we can use the logger.\n      // This is so it can get the current log level.\n\n\n      {\n        const padding = '   ';\n        defaultExport.groupCollapsed('Welcome to Workbox!');\n        defaultExport.unprefixed.log(`You are currently using a development build. ` + `By default this will switch to prod builds when not on localhost. ` + `You can force this with workbox.setConfig({debug: true|false}).`);\n        defaultExport.unprefixed.log(`📖 Read the guides and documentation\\n` + `${padding}https://developers.google.com/web/tools/workbox/`);\n        defaultExport.unprefixed.log(`❓ Use the [workbox] tag on Stack Overflow to ask questions\\n` + `${padding}https://stackoverflow.com/questions/ask?tags=workbox`);\n        defaultExport.unprefixed.log(`🐛 Found a bug? Report it on GitHub\\n` + `${padding}https://github.com/GoogleChrome/workbox/issues/new`);\n        defaultExport.groupEnd();\n\n        if (typeof finalCheckSWFileCacheHeaders === 'function') {\n          finalCheckSWFileCacheHeaders();\n        }\n      }\n    }\n    /**\n     * Get the current cache names used by Workbox.\n     *\n     * `cacheNames.precache` is used for precached assets,\n     * `cacheNames.googleAnalytics` is used by `workbox-google-analytics` to\n     * store `analytics.js`,\n     * and `cacheNames.runtime` is used for everything else.\n     *\n     * @return {Object} An object with `precache` and `runtime` cache names.\n     *\n     * @alias workbox.core.cacheNames\n     */\n\n\n    get cacheNames() {\n      return {\n        googleAnalytics: cacheNames.getGoogleAnalyticsName(),\n        precache: cacheNames.getPrecacheName(),\n        runtime: cacheNames.getRuntimeName()\n      };\n    }\n    /**\n     * You can alter the default cache names used by the Workbox modules by\n     * changing the cache name details.\n     *\n     * Cache names are generated as `<prefix>-<Cache Name>-<suffix>`.\n     *\n     * @param {Object} details\n     * @param {Object} details.prefix The string to add to the beginning of\n     * the precache and runtime cache names.\n     * @param {Object} details.suffix The string to add to the end of\n     * the precache and runtime cache names.\n     * @param {Object} details.precache The cache name to use for precache\n     * caching.\n     * @param {Object} details.runtime The cache name to use for runtime caching.\n     * @param {Object} details.googleAnalytics The cache name to use for\n     * `workbox-google-analytics` caching.\n     *\n     * @alias workbox.core.setCacheNameDetails\n     */\n\n\n    setCacheNameDetails(details) {\n      {\n        Object.keys(details).forEach(key => {\n          finalAssertExports.isType(details[key], 'string', {\n            moduleName: 'workbox-core',\n            className: 'WorkboxCore',\n            funcName: 'setCacheNameDetails',\n            paramName: `details.${key}`\n          });\n        });\n\n        if ('precache' in details && details.precache.length === 0) {\n          throw new WorkboxError('invalid-cache-name', {\n            cacheNameId: 'precache',\n            value: details.precache\n          });\n        }\n\n        if ('runtime' in details && details.runtime.length === 0) {\n          throw new WorkboxError('invalid-cache-name', {\n            cacheNameId: 'runtime',\n            value: details.runtime\n          });\n        }\n\n        if ('googleAnalytics' in details && details.googleAnalytics.length === 0) {\n          throw new WorkboxError('invalid-cache-name', {\n            cacheNameId: 'googleAnalytics',\n            value: details.googleAnalytics\n          });\n        }\n      }\n\n      cacheNames.updateDetails(details);\n    }\n    /**\n     * Get the current log level.\n     *\n     * @return {number}.\n     *\n     * @alias workbox.core.logLevel\n     */\n\n\n    get logLevel() {\n      return getLoggerLevel();\n    }\n    /**\n     * Set the current log level passing in one of the values from\n     * [LOG_LEVELS]{@link module:workbox-core.LOG_LEVELS}.\n     *\n     * @param {number} newLevel The new log level to use.\n     *\n     * @alias workbox.core.setLogLevel\n     */\n\n\n    setLogLevel(newLevel) {\n      {\n        finalAssertExports.isType(newLevel, 'number', {\n          moduleName: 'workbox-core',\n          className: 'WorkboxCore',\n          funcName: 'logLevel [setter]',\n          paramName: `logLevel`\n        });\n      }\n\n      if (newLevel > LOG_LEVELS.silent || newLevel < LOG_LEVELS.debug) {\n        throw new WorkboxError('invalid-value', {\n          paramName: 'logLevel',\n          validValueDescription: `Please use a value from LOG_LEVELS, i.e ` + `'logLevel = workbox.core.LOG_LEVELS.debug'.`,\n          value: newLevel\n        });\n      }\n\n      setLoggerLevel(newLevel);\n    }\n\n  }\n\n  var defaultExport$1 = new WorkboxCore();\n\n  /*\n    Copyright 2018 Google LLC\n\n    Use of this source code is governed by an MIT-style\n    license that can be found in the LICENSE file or at\n    https://opensource.org/licenses/MIT.\n  */\n  const finalExports = Object.assign(defaultExport$1, {\n    _private,\n    LOG_LEVELS,\n    registerQuotaErrorCallback\n  });\n\n  return finalExports;\n\n}());\n"],"file":"workbox-core.dev.js"}