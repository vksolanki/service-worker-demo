{"version":3,"names":[],"mappings":"","sources":["packages/workbox-strategies/browser.mjs"],"sourcesContent":["this.workbox=this.workbox||{},this.workbox.strategies=function(e,t,s,n){\"use strict\";try{self.workbox.v[\"workbox:strategies:4.0.0-beta.0\"]=1}catch(e){}class r{constructor(t={}){this.e=e.cacheNames.getRuntimeName(t.cacheName),this.t=t.plugins||[],this.s=t.fetchOptions||null,this.n=t.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:s}){\"string\"==typeof s&&(s=new Request(s));let r,i=await t.cacheWrapper.match({cacheName:this.e,request:s,event:e,matchOptions:this.n,plugins:this.t});if(!i)try{i=await this.r(s,e)}catch(e){r=e}if(!i)throw new n.WorkboxError(\"no-response\",{url:s.url,error:r});return i}async r(e,n){const r=await s.fetchWrapper.fetch({request:e,event:n,fetchOptions:this.s,plugins:this.t}),i=r.clone(),h=t.cacheWrapper.put({cacheName:this.e,request:e,response:i,event:n,plugins:this.t});if(n)try{n.waitUntil(h)}catch(e){}return r}}class i{constructor(t={}){this.e=e.cacheNames.getRuntimeName(t.cacheName),this.t=t.plugins||[],this.n=t.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:s}){\"string\"==typeof s&&(s=new Request(s));const r=await t.cacheWrapper.match({cacheName:this.e,request:s,event:e,matchOptions:this.n,plugins:this.t});if(!r)throw new n.WorkboxError(\"no-response\",{url:s.url});return r}}var h={cacheWillUpdate:({response:e})=>e.ok||0===e.status?e:null};class u{constructor(t={}){if(this.e=e.cacheNames.getRuntimeName(t.cacheName),t.plugins){let e=t.plugins.some(e=>!!e.cacheWillUpdate);this.t=e?t.plugins:[h,...t.plugins]}else this.t=[h];this.i=t.networkTimeoutSeconds,this.s=t.fetchOptions||null,this.n=t.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){const s=[];\"string\"==typeof t&&(t=new Request(t));const r=[];let i;if(this.i){const{id:n,promise:h}=this.h({request:t,event:e,logs:s});i=n,r.push(h)}const h=this.u({timeoutId:i,request:t,event:e,logs:s});r.push(h);let u=await Promise.race(r);if(u||(u=await h),!u)throw new n.WorkboxError(\"no-response\",{url:t.url});return u}h({request:e,logs:t,event:s}){let n;return{promise:new Promise(t=>{n=setTimeout(async()=>{t(await this.a({request:e,event:s}))},1e3*this.i)}),id:n}}async u({timeoutId:e,request:n,logs:r,event:i}){let h,u;try{u=await s.fetchWrapper.fetch({request:n,event:i,fetchOptions:this.s,plugins:this.t})}catch(e){h=e}if(e&&clearTimeout(e),h||!u)u=await this.a({request:n,event:i});else{const e=u.clone(),s=t.cacheWrapper.put({cacheName:this.e,request:n,response:e,event:i,plugins:this.t});if(i)try{i.waitUntil(s)}catch(e){}}return u}a({event:e,request:s}){return t.cacheWrapper.match({cacheName:this.e,request:s,event:e,matchOptions:this.n,plugins:this.t})}}class a{constructor(t={}){this.e=e.cacheNames.getRuntimeName(t.cacheName),this.t=t.plugins||[],this.s=t.fetchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:t}){let r,i;\"string\"==typeof t&&(t=new Request(t));try{i=await s.fetchWrapper.fetch({request:t,event:e,fetchOptions:this.s,plugins:this.t})}catch(e){r=e}if(!i)throw new n.WorkboxError(\"no-response\",{url:t.url,error:r});return i}}class c{constructor(t={}){if(this.e=e.cacheNames.getRuntimeName(t.cacheName),this.t=t.plugins||[],t.plugins){let e=t.plugins.some(e=>!!e.cacheWillUpdate);this.t=e?t.plugins:[h,...t.plugins]}else this.t=[h];this.s=t.fetchOptions||null,this.n=t.matchOptions||null}async handle({event:e,request:t}){return this.makeRequest({event:e,request:t||e.request})}async makeRequest({event:e,request:s}){\"string\"==typeof s&&(s=new Request(s));const r=this.r({request:s,event:e});let i,h=await t.cacheWrapper.match({cacheName:this.e,request:s,event:e,matchOptions:this.n,plugins:this.t});if(h){if(e)try{e.waitUntil(r)}catch(i){}}else try{h=await r}catch(e){i=e}if(!h)throw new n.WorkboxError(\"no-response\",{url:s.url,error:i});return h}async r({request:e,event:n}){const r=await s.fetchWrapper.fetch({request:e,event:n,fetchOptions:this.s,plugins:this.t}),i=t.cacheWrapper.put({cacheName:this.e,request:e,response:r.clone(),event:n,plugins:this.t});if(n)try{n.waitUntil(i)}catch(e){}return r}}var o=Object.freeze({CacheFirst:r,CacheOnly:i,NetworkFirst:u,NetworkOnly:a,StaleWhileRevalidate:c});const l={cacheFirst:r,cacheOnly:i,networkFirst:u,networkOnly:a,staleWhileRevalidate:c},q={};return Object.keys(l).forEach(e=>{q[e]=((t={})=>{return new(0,l[e])(Object.assign(t))})}),Object.assign(q,o)}(workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private);\n"],"file":"workbox-strategies.prod.js"}